<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Umbrella Sampling &#8212; OpenMM Cookbook &amp; Tutorials refs/tags/v0.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a0d4cc31" />
    <link rel="stylesheet" type="text/css" href="../../_static/nbsphinx-code-cells.css?v=2aa19091" />
    <link rel="stylesheet" type="text/css" href="../../_static/notebooks.css?v=9b8a9a20" />
    <script src="../../_static/documentation_options.js?v=51e9a46a"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="prev" title="Replica Exchange Solute Tempering (REST)" href="Running_a_REST_simulation.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="nbsphinx-prolog">
    <a href="umbrella_sampling.ipynb">Download Notebook</a>
    <a href="https://github.com/openmm/openmm-cookbook/blob/main/notebooks/tutorials/umbrella_sampling.ipynb">View in GitHub</a>
    <a href="https://colab.research.google.com/github/openmm/openmm-cookbook/blob/gh-pages/refs/tags/v0.5/colab/notebooks/tutorials/umbrella_sampling.ipynb">Open in Google Colab</a>
</div><span class="target" id="index-0"></span><section id="Umbrella-Sampling">
<h1>Umbrella Sampling<a class="headerlink" href="#Umbrella-Sampling" title="Link to this heading">¶</a></h1>
<section id="Introduction">
<h2>Introduction<a class="headerlink" href="#Introduction" title="Link to this heading">¶</a></h2>
<p>Umbrella sampling is a technique used in molecular dynamics simulations to improve sampling in systems containing high barriers in the free energy landscape. With plain MD simulations the system can remain trapped in free energy minima whereas umbrella sampling adds extra biasing potentials to drive the system in the direction of a chosen collective variable (CV). This enables the calculation of free energy profiles much more efficiently than is possible with regular MD alone.</p>
</section>
<section id="Theory">
<h2>Theory<a class="headerlink" href="#Theory" title="Link to this heading">¶</a></h2>
<p>This section explains more of the details behind umbrella sampling. Refer to [<a class="reference internal" href="#References"><span class="std std-ref">1</span></a>, <a class="reference internal" href="#References"><span class="std std-ref">2</span></a>] for full information. The text in this section is from [<a class="reference internal" href="#References"><span class="std std-ref">3</span></a>].</p>
<p>The free energy of a system in the canonical ensemble is</p>
<div class="math notranslate nohighlight">
\[F=-k_B T \text{log}(Z),\]</div>
<p>where <span class="math notranslate nohighlight">\(Z\)</span> is the canonical partition function. For all but the smallest systems <span class="math notranslate nohighlight">\(Z\)</span> is computationally intractable to calculate. However, often the most interesting information about a molecular system is given by the differences in the free energy across system states. A Collective Variable (CV; also called a reaction coordinate) can be defined which is a continuous variable that distinguishes different states. The simplest types of CVs are geometric distances (e.g. the distance
between two molecules) but there are many other possibilities. The CV <span class="math notranslate nohighlight">\(x\)</span> is a function of the atomic coordinates, <span class="math notranslate nohighlight">\(x(r)\)</span>, and multiple different realizations of <span class="math notranslate nohighlight">\(r\)</span> can map to the same <span class="math notranslate nohighlight">\(x\)</span>. The probability distribution of the system can be written in terms of <span class="math notranslate nohighlight">\(x\)</span>:</p>
<div class="math notranslate nohighlight">
\[p(x) \propto \int{ e^{-\beta E(r)} \delta (x-x(r))dr},\]</div>
<p>where we have integrated the Boltzmann distribution over all degrees of freedom for each value of <span class="math notranslate nohighlight">\(x\)</span>. The probability can be turned into a free energy:</p>
<div class="math notranslate nohighlight">
\[F(x) = -k_B T \text{log} (p(x)) + C,\]</div>
<p>where <span class="math notranslate nohighlight">\(C\)</span> is a constant and unimportant as we are only interested in <span class="math notranslate nohighlight">\(∆F\)</span>. In theory, the free energy profile along <span class="math notranslate nohighlight">\(x\)</span> could be computed by sampling the system in equilibrium and recording the probability histogram of the values of <span class="math notranslate nohighlight">\(x\)</span> which occur. However, for any non-trivial potential energy surface it will take a very long time to achieve sufficient sampling to get an adequately converged histogram — the high energy states will not be sampled.</p>
<p>To enhance the sampling umbrella sampling can be used. This adds additional biasing potentials <span class="math notranslate nohighlight">\(w(x)\)</span> to the system to restrain it at certain values of <span class="math notranslate nohighlight">\(x\)</span>. The form of <span class="math notranslate nohighlight">\(w\)</span> is usually a harmonic term:</p>
<div class="math notranslate nohighlight">
\[w(x) = \frac{1}{2} k (x-x_0)^2,\]</div>
<p>where <span class="math notranslate nohighlight">\(k\)</span> is a constant with units of energy per units of <span class="math notranslate nohighlight">\(x\)</span> squared. We then run multiple simulations, each restrained with a different <span class="math notranslate nohighlight">\(w\)</span>, and then combine them to generate a probability distribution that sufficiently samples the whole range of <span class="math notranslate nohighlight">\(x\)</span>. The process is illustrated in figure 1 and explained in more detail as follows.</p>
<p><img alt="umbrella_sampling" src="../../_images/umbrella_sampling.svg" /></p>
<p><strong>Figure 1. Umbrella sampling method to compute a free energy profile.</strong> (a) Multiple biasing potentials are placed across the collective variable <span class="math notranslate nohighlight">\(x\)</span>. The blue curve is the free energy of the system which we are trying to calculate. (b) Simulations are run for each window <span class="math notranslate nohighlight">\(w\)</span>. The resulting biased probability distributions <span class="math notranslate nohighlight">\(P'(x)\)</span> are plotted. (c) The unbiased free energies <span class="math notranslate nohighlight">\(F_i\)</span> from each window. They are each offset by a different <span class="math notranslate nohighlight">\(C_i\)</span>. (d) The Weighted
Histogram Analysis Method (WHAM) is used to combine the windows and compute the free energy curve.</p>
<p>With a biasing potential <span class="math notranslate nohighlight">\(w(x(r))\)</span> the potential energy of the system becomes</p>
<div class="math notranslate nohighlight">
\[E'(r) = E(r) + w((x(r)))\]</div>
<p>which leads to a probability distribution (in the canonical ensemble) of</p>
<div class="math notranslate nohighlight">
\[p'(x) \propto \int e^{-\beta (E + w)} \delta (x - x(r)) dr \propto p(x) e^{-\beta w(x)},\]</div>
<p>and a free energy of</p>
<div class="math notranslate nohighlight">
\[F'(x) = -k_B T \text{log}(p(x)) + w(x) + C = F(x) + w(x) + C.\]</div>
<p>Thus, the unbiased free energy <span class="math notranslate nohighlight">\(F\)</span> can be obtained by subtracting the biasing potential <span class="math notranslate nohighlight">\(w\)</span> from the biased free energy <span class="math notranslate nohighlight">\(F'\)</span>. However, when more than one biasing window is used the value of <span class="math notranslate nohighlight">\(C\)</span> cannot be neglected as it will be different for each window. For multiple biasing windows we have a set of unbiased (but offset by different <span class="math notranslate nohighlight">\(C_i\)</span>) free energies,</p>
<div class="math notranslate nohighlight">
\[F_i(x) = -k_B T \text{log}(p'_i) + w_i + C_i.\]</div>
<p>To compute <span class="math notranslate nohighlight">\(F\)</span> over the full range of <span class="math notranslate nohighlight">\(x\)</span> the different <span class="math notranslate nohighlight">\(F_i(x)\)</span> need to be combined. This can be accomplished by the Weighted Histogram Analysis Method (WHAM) [<a class="reference internal" href="#References"><span class="std std-ref">1</span></a>]. The WHAM equations are shown in <a class="reference internal" href="#WHAM-equations"><span class="std std-ref">appendix section 2</span></a>. The free energy profile is also called the Potential of Mean Force (PMF); in this example we will assume they are equivalent and use them interchangeably.</p>
</section>
<section id="Umbrella-sampling-simulations">
<h2>Umbrella sampling simulations<a class="headerlink" href="#Umbrella-sampling-simulations" title="Link to this heading">¶</a></h2>
<p>Most umbrella sampling simulations have three main steps:</p>
<ol class="arabic simple">
<li><p>Preparing the windows. This is usually done using Steered Molecular Dynamics (SMD; see <a class="reference internal" href="#Steered-MD"><span class="std std-ref">appendix section 1</span></a>).</p></li>
<li><p>Running the windows. These can be computed in parallel to take advantage of compute resources.</p></li>
<li><p>Analysing the results. Typically this involves computing a PMF with WHAM.</p></li>
</ol>
<p>Often you will find in step 3 that the simulations do not produce a nicely converged PMF. You will need to return to step 1 and change some settings. This trial and improvement feedback loop is a normal part of the process. For this tutorial we will use settings already known to work.</p>
</section>
<section id="System">
<h2>System<a class="headerlink" href="#System" title="Link to this heading">¶</a></h2>
<p>This tutorial will use umbrella sampling to compute the free energy profile of the end-to-end distance (<span class="math notranslate nohighlight">\(r\)</span>) of deca-alanine in vacuum. Deca-alanine is commonly used as a toy system [<a class="reference internal" href="#References"><span class="std std-ref">4</span></a>]. Its equilibrium structure is a stable alpha-helix. Starting with the alpha-helix structure we will first perform a SMD simulation to pull it from a helix into a coil. Next, we will run 24 umbrella sampling windows in the range <span class="math notranslate nohighlight">\(1.3\ \mathrm{nm}\)</span> to <span class="math notranslate nohighlight">\(3.3\ \mathrm{nm}\)</span>. Finally,
we will compute the PMF along <span class="math notranslate nohighlight">\(r\)</span>. Figure 2 shows the initial alpha-helix structure and the final extended coil structure.</p>
<p><img alt="deca-alanine" src="../../_images/deca-alanine.png" /></p>
<p><strong>Figure 2</strong> Structure of deca-alanine for end-to-end distance <span class="math notranslate nohighlight">\(r=1.3\ \mathrm{nm}\)</span> and <span class="math notranslate nohighlight">\(r=3.3\ \mathrm{nm}\)</span>.</p>
</section>
<section id="Step-1-—-Setting-up-the-windows-with-SMD">
<h2>Step 1 — Setting up the windows with SMD<a class="headerlink" href="#Step-1-—-Setting-up-the-windows-with-SMD" title="Link to this heading">¶</a></h2>
<p>The script below does the following steps:</p>
<ul class="simple">
<li><p>Loads in a PDB file.</p></li>
<li><p>Defines a collective variable between the first and last alpha-carbon.</p></li>
<li><p>Adds a harmonic restraint to the CV.</p></li>
<li><p>Runs a simulation where the location of the harmonic restraint is moved with constant velocity from <span class="math notranslate nohighlight">\(1.3\ \mathrm{nm}\)</span> to <span class="math notranslate nohighlight">\(3.3\ \mathrm{nm}\)</span> (This is called constant velocity steered MD).</p></li>
<li><p>Saves a configuration for each of the 24 equally spaced windows between <span class="math notranslate nohighlight">\(1.3\ \mathrm{nm}\)</span> and <span class="math notranslate nohighlight">\(3.3\ \mathrm{nm}\)</span>.</p></li>
</ul>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">openmm</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mm</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">openmm.app</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">app</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">openmm.unit</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">unit</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sys</span><span class="w"> </span><span class="kn">import</span> <span class="n">stdout</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">pdb</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">PDBFile</span><span class="p">(</span><span class="s1">&#39;deca-ala.pdb&#39;</span><span class="p">)</span>

<span class="n">forcefield</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">ForceField</span><span class="p">(</span><span class="s1">&#39;amber14-all.xml&#39;</span><span class="p">)</span>

<span class="c1"># We have a single molecule in vacuum so we use no cutoff.</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">forcefield</span><span class="o">.</span><span class="n">createSystem</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">topology</span><span class="p">,</span> <span class="n">nonbondedMethod</span><span class="o">=</span><span class="n">app</span><span class="o">.</span><span class="n">NoCutoff</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">app</span><span class="o">.</span><span class="n">HBonds</span><span class="p">,</span> <span class="n">hydrogenMass</span><span class="o">=</span><span class="mf">1.5</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">amu</span><span class="p">)</span>
<span class="n">integrator</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">LangevinMiddleIntegrator</span><span class="p">(</span><span class="mi">300</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">kelvin</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">unit</span><span class="o">.</span><span class="n">picosecond</span><span class="p">,</span> <span class="mf">0.004</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">picoseconds</span><span class="p">)</span>
<span class="n">simulation</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">topology</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">integrator</span><span class="p">)</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">setPositions</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">reporters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">DCDReporter</span><span class="p">(</span><span class="s1">&#39;smd_traj.dcd&#39;</span><span class="p">,</span> <span class="mi">10000</span><span class="p">))</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">reporters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">StateDataReporter</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">potentialEnergy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">speed</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

<span class="c1"># equilibrate</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">setVelocitiesToTemperature</span><span class="p">(</span><span class="mi">300</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">kelvin</span><span class="p">)</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># define the CV as the distance between the CAs of the two end residues</span>
<span class="n">index1</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">index2</span> <span class="o">=</span> <span class="mi">98</span>
<span class="n">cv</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">CustomBondForce</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">cv</span><span class="o">.</span><span class="n">addBond</span><span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">index2</span><span class="p">)</span>

<span class="c1"># now setup SMD</span>

<span class="c1"># starting value</span>
<span class="n">r0</span> <span class="o">=</span> <span class="mf">1.3</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">nanometers</span>

<span class="c1"># force constant</span>
<span class="n">fc_pull</span> <span class="o">=</span> <span class="mf">1000.0</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">kilojoules_per_mole</span><span class="o">/</span><span class="n">unit</span><span class="o">.</span><span class="n">nanometers</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># pulling speed</span>
<span class="n">v_pulling</span> <span class="o">=</span> <span class="mf">0.02</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">nanometers</span><span class="o">/</span><span class="n">unit</span><span class="o">.</span><span class="n">picosecond</span> <span class="c1"># nm/ps</span>

<span class="c1"># simulation time step</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">simulation</span><span class="o">.</span><span class="n">integrator</span><span class="o">.</span><span class="n">getStepSize</span><span class="p">()</span>

<span class="c1"># total number of steps</span>
<span class="n">total_steps</span> <span class="o">=</span> <span class="mi">30000</span> <span class="c1"># 120ps</span>

<span class="c1"># number of steps to run between incrementing r0 (1 makes the simulation slow)</span>
<span class="n">increment_steps</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># define a harmonic restraint on the CV</span>
<span class="c1"># the location of the restrain will be moved as we run the simulation</span>
<span class="c1"># this is constant velocity steered MD</span>
<span class="n">pullingForce</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">CustomCVForce</span><span class="p">(</span><span class="s1">&#39;0.5 * fc_pull * (cv-r0)^2&#39;</span><span class="p">)</span>
<span class="n">pullingForce</span><span class="o">.</span><span class="n">addGlobalParameter</span><span class="p">(</span><span class="s1">&#39;fc_pull&#39;</span><span class="p">,</span> <span class="n">fc_pull</span><span class="p">)</span>
<span class="n">pullingForce</span><span class="o">.</span><span class="n">addGlobalParameter</span><span class="p">(</span><span class="s1">&#39;r0&#39;</span><span class="p">,</span> <span class="n">r0</span><span class="p">)</span>
<span class="n">pullingForce</span><span class="o">.</span><span class="n">addCollectiveVariable</span><span class="p">(</span><span class="s2">&quot;cv&quot;</span><span class="p">,</span> <span class="n">cv</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">addForce</span><span class="p">(</span><span class="n">pullingForce</span><span class="p">)</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">reinitialize</span><span class="p">(</span><span class="n">preserveState</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># define the windows</span>
<span class="c1"># during the pulling loop we will save specific configurations corresponding to the windows</span>
<span class="n">windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
<span class="n">window_coords</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">window_index</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># SMD pulling loop</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_steps</span><span class="o">//</span><span class="n">increment_steps</span><span class="p">):</span>
    <span class="n">simulation</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">increment_steps</span><span class="p">)</span>
    <span class="n">current_cv_value</span> <span class="o">=</span> <span class="n">pullingForce</span><span class="o">.</span><span class="n">getCollectiveVariableValues</span><span class="p">(</span><span class="n">simulation</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">increment_steps</span><span class="p">)</span><span class="o">%</span><span class="k">5000</span> == 0:
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;r0 = &quot;</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="s2">&quot;r = &quot;</span><span class="p">,</span> <span class="n">current_cv_value</span><span class="p">)</span>

    <span class="c1"># increment the location of the CV based on the pulling velocity</span>
    <span class="n">r0</span> <span class="o">+=</span> <span class="n">v_pulling</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">increment_steps</span>
    <span class="n">simulation</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">setParameter</span><span class="p">(</span><span class="s1">&#39;r0&#39;</span><span class="p">,</span><span class="n">r0</span><span class="p">)</span>

    <span class="c1"># check if we should save this config as a window starting structure</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">window_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span> <span class="ow">and</span> <span class="n">current_cv_value</span> <span class="o">&gt;=</span> <span class="n">windows</span><span class="p">[</span><span class="n">window_index</span><span class="p">]):</span>
        <span class="n">window_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simulation</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">getState</span><span class="p">(</span><span class="n">getPositions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enforcePeriodicBox</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">getPositions</span><span class="p">())</span>
        <span class="n">window_index</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># save the window structures</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coords</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">window_coords</span><span class="p">):</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;window_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">.pdb&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">PDBFile</span><span class="o">.</span><span class="n">writeFile</span><span class="p">(</span><span class="n">simulation</span><span class="o">.</span><span class="n">topology</span><span class="p">,</span><span class="n">coords</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
    <span class="n">outfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>Once the script has completed running there will be 24 new PDB files called “window_n.pdb” where n is an integer from 0 to 23.</p>
<p>We now have the initial configurations for the umbrella sampling windows.</p>
</section>
<section id="Step-2-—-Running-the-windows">
<h2>Step 2 — Running the windows<a class="headerlink" href="#Step-2-—-Running-the-windows" title="Link to this heading">¶</a></h2>
<p>The script to run the windows is very similar to the script in step 1. The key differences are that we load in an initial structure that corresponds to each specific window and that the harmonic restraint on the CV does not move. The script below defines a function to run one window. It re-uses the <code class="docutils literal notranslate"><span class="pre">Simulation</span></code> we created in step 1.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">run_window</span><span class="p">(</span><span class="n">window_index</span><span class="p">):</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;running window&#39;</span><span class="p">,</span> <span class="n">window_index</span><span class="p">)</span>

    <span class="c1"># load in the starting configuration for this window</span>
    <span class="n">pdb</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">PDBFile</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;window_</span><span class="si">{</span><span class="n">window_index</span><span class="si">}</span><span class="s1">.pdb&#39;</span><span class="p">)</span>

    <span class="c1"># we can reuse the existing Simulation</span>
    <span class="n">simulation</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">setPositions</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>

    <span class="c1"># set the fixed location of the harmonic restraint for this window</span>
    <span class="n">r0</span> <span class="o">=</span> <span class="n">windows</span><span class="p">[</span><span class="n">window_index</span><span class="p">]</span>
    <span class="n">simulation</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">setParameter</span><span class="p">(</span><span class="s1">&#39;r0&#39;</span><span class="p">,</span> <span class="n">r0</span><span class="p">)</span>

    <span class="c1"># run short equilibration with new positions and r0</span>
    <span class="n">simulation</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">setVelocitiesToTemperature</span><span class="p">(</span><span class="mi">300</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">kelvin</span><span class="p">)</span>
    <span class="n">simulation</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>

    <span class="c1"># run the data collection</span>

    <span class="c1"># total number of steps</span>
    <span class="n">total_steps</span> <span class="o">=</span> <span class="mi">100000</span> <span class="c1"># 400 ps</span>

    <span class="c1"># frequency to record the current CV value</span>
    <span class="n">record_steps</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="c1"># run the simulation and record the value of the CV.</span>
    <span class="n">cv_values</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_steps</span><span class="o">//</span><span class="n">record_steps</span><span class="p">):</span>
        <span class="n">simulation</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">record_steps</span><span class="p">)</span>

        <span class="c1"># get the current value of the cv</span>
        <span class="n">current_cv_value</span> <span class="o">=</span> <span class="n">pullingForce</span><span class="o">.</span><span class="n">getCollectiveVariableValues</span><span class="p">(</span><span class="n">simulation</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>
        <span class="n">cv_values</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">current_cv_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

    <span class="c1"># save the CV timeseries to a file so we can postprocess</span>
    <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cv_values_window_</span><span class="si">{</span><span class="n">window_index</span><span class="si">}</span><span class="s1">.txt&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cv_values</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Completed window&#39;</span><span class="p">,</span> <span class="n">window_index</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>We then run all 24 windows:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">24</span><span class="p">):</span>
    <span class="n">run_window</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Once all the window simulations have completed you will have the CV timeseries files: “cv_values_window_n.txt”</p>
</section>
<section id="Step-3-—-Analysis-—-compute-the-PMF">
<h2>Step 3 — Analysis — compute the PMF<a class="headerlink" href="#Step-3-—-Analysis-—-compute-the-PMF" title="Link to this heading">¶</a></h2>
<p>The first thing to check is that the histograms of the CV timeseries have good overlap. Here is an example: <img alt="histogram" src="../../_images/hist.png" /></p>
<p>You can plot yours with the script below (This script also produces the metadata file we will need for the next step).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># plot the histograms</span>
<span class="n">metafilelines</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">)):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cv_values_window_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">.txt&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">metafileline</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;cv_values_window_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">.txt </span><span class="si">{</span><span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1"> 1000</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">metafilelines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">metafileline</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;r (nm)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;metafile.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">metafilelines</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>To compute the PMF we can use WHAM [<a class="reference internal" href="#References"><span class="std std-ref">1</span></a>]. An easy to use and widely compatible implementation is the WHAM program by Alan Grossfield which can be downloaded <a class="reference external" href="http://membrane.urmc.rochester.edu/?page_id=126">here</a>. It is a C program so it will need to be compiled. The command below should work on Linux and Mac.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>wget<span class="w"> </span>http://membrane.urmc.rochester.edu/sites/default/files/wham/wham-release-2.0.11.tgz
<span class="o">!</span>tar<span class="w"> </span>xf<span class="w"> </span>wham-release-2.0.11.tgz
<span class="o">!</span><span class="nb">cd</span><span class="w"> </span>wham/wham<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>make
</pre></div>
</div>
</div>
<p>To use <code class="docutils literal notranslate"><span class="pre">wham</span></code> we need a metadata file that lists the names of each CV timeseries file, the location of the harmonic restraints, and the value of the spring constant. We created this in the histogram plotting script earlier.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">wham</span></code> program is run using command line arguments. Read the <a class="reference external" href="http://membrane.urmc.rochester.edu/sites/default/files/wham/doc.pdf">documentation</a> to find out more.</p>
<p>The command below will compute the PMF from our data. The command line arguments correspond to a range of <span class="math notranslate nohighlight">\(1.3\ \mathrm{nm}\)</span> to <span class="math notranslate nohighlight">\(3.3\ \mathrm{nm}\)</span>, 50 histogram bins, a tolerance of <span class="math notranslate nohighlight">\(10^{-6}\)</span>, and a temperature of <span class="math notranslate nohighlight">\(300\ \mathrm{K}\)</span>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>./wham/wham/wham<span class="w"> </span><span class="m">1</span>.3<span class="w"> </span><span class="m">3</span>.3<span class="w"> </span><span class="m">50</span><span class="w"> </span>1e-6<span class="w"> </span><span class="m">300</span><span class="w"> </span><span class="m">0</span><span class="w"> </span>metafile.txt<span class="w"> </span>pmf.txt<span class="w"> </span>&gt;<span class="w"> </span>wham_log.txt
</pre></div>
</div>
</div>
<p>We can then plot the computed PMF. It should look something like this: <img alt="pmf.png" src="../../_images/pmf.png" /></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># plot the PMF</span>
<span class="n">pmf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s2">&quot;pmf.txt&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pmf</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pmf</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;r (nm)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;PMF (kJ/mol)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</section>
<section id="Next-steps">
<h2>Next steps<a class="headerlink" href="#Next-steps" title="Link to this heading">¶</a></h2>
<p>You should now perform error analysis to confirm the PMF you have calculated is an accurate representation of the system you are simulating. Here are a few suggestions:</p>
<ul class="simple">
<li><p>Run some completely independent repeats and check the computed PMFs are the same.</p></li>
<li><p>Perform the initial steered MD loop at a slower speed. If this step is too fast your windows will have initial states that are far from equilibrium.</p></li>
<li><p>Run the windows for longer. If you have sampled enough then with longer runtime the calculated PMF should be the same. If the PMF is different it means your initial simulations were not long enough. Increase the runtime until the calculated PMFs are the same.</p></li>
<li><p>Similarly, using more windows you should get the same results.</p></li>
</ul>
<p>Other tips:</p>
<ul class="simple">
<li><p>If the histograms have poor overlap you will need to use more windows and/or reduce the spring constant.</p></li>
<li><p>The windows do not need to be linearly spaced and they can have different spring constants.</p></li>
</ul>
</section>
<section id="References">
<h2>References<a class="headerlink" href="#References" title="Link to this heading">¶</a></h2>
<div class="line-block">
<div class="line">[1] Kumar, S., Rosenberg, J.M., Bouzida, D., Swendsen, R.H. and Kollman, P.A. (1992), <em>The weighted histogram analysis method for free-energy calculations on biomolecules. I. The method.</em> J. Comput. Chem., 13: 1011-1021. <a class="reference external" href="https://doi.org/10.1002/jcc.540130812">https://doi.org/10.1002/jcc.540130812</a></div>
<div class="line">[2] Kästner, J. (2011), <em>Umbrella sampling.</em> WIREs Comput Mol Sci, 1: 932-942. <a class="reference external" href="https://doi.org/10.1002/wcms.66">https://doi.org/10.1002/wcms.66</a></div>
<div class="line">[3] Farr, S. (2021), <a class="reference external" href="https://doi.org/10.17863/CAM.72078">https://doi.org/10.17863/CAM.72078</a></div>
<div class="line">[4] Park, S., Khalili-Araghi, F., Tajkhorshid, E., and Schulten, K. (2003), <em>Free energy calculation from steered molecular dynamics simulations using Jarzynski’s equality.</em> J. Chem. Phys., 119 (6): 3559–3566. <a class="reference external" href="https://doi.org/10.1063/1.1590311">https://doi.org/10.1063/1.1590311</a></div>
</div>
</section>
<section id="Appendix">
<h2>Appendix<a class="headerlink" href="#Appendix" title="Link to this heading">¶</a></h2>
<section id="Steered-MD">
<h3>Steered MD<a class="headerlink" href="#Steered-MD" title="Link to this heading">¶</a></h3>
<p>Steered MD is a non-equilibrium method which means great care must be taken to ensure the results you get are meaningful. In this tutorial steered MD is just used in the setup phase and we do not calculate any properties with it. In constant velocity steered MD the biasing potential has the form</p>
<div class="math notranslate nohighlight">
\[w = \frac{1}{2} k (x-x_0(t))^2,\]</div>
<div class="math notranslate nohighlight">
\[x_0(t) = x_0(0)+vt,\]</div>
<p>which is just a moving version of the umbrella window bias potential.</p>
</section>
<section id="WHAM-equations">
<h3>WHAM equations<a class="headerlink" href="#WHAM-equations" title="Link to this heading">¶</a></h3>
<p>The WHAM equations [1] are:</p>
<div class="math notranslate nohighlight">
\[P(x_j) = \frac{\sum^{N_w}_i h_i(x_j)}{\sum^{N_w}_i n_i e^ {\beta(C_i - w_i(x_j))} },\]</div>
<div class="math notranslate nohighlight">
\[C_i = -k_B T \log\left( \sum_j P(x_j) e^{-\beta w_i(x_j)} \right).\]</div>
<p>Where they have been written in a fully discretized form. <span class="math notranslate nohighlight">\(P(x_j)\)</span> is the resulting unbiased probability distribution where <span class="math notranslate nohighlight">\(j\)</span> is the index for the discrete set of <span class="math notranslate nohighlight">\(x_j\)</span> that <span class="math notranslate nohighlight">\(P\)</span> is computed over. <span class="math notranslate nohighlight">\(N_w\)</span> is the number of windows, <span class="math notranslate nohighlight">\(i\)</span> is the index of each window, <span class="math notranslate nohighlight">\(n_i\)</span> is the number of data points (realizations of <span class="math notranslate nohighlight">\(x\)</span>) in the <span class="math notranslate nohighlight">\(i\)</span>-th window trajectory, <span class="math notranslate nohighlight">\(h_i(x_j)\)</span> is the number of points in histogram bin <span class="math notranslate nohighlight">\(j\)</span> from trajectory
<span class="math notranslate nohighlight">\(i\)</span>, and <span class="math notranslate nohighlight">\(w_i\)</span> are the biasing potentials. Both equations depend on each other so must be solved self-consistently. In practice this is solved iteratively: initial guesses of <span class="math notranslate nohighlight">\(C_i\)</span> are chosen, <span class="math notranslate nohighlight">\(P\)</span> is then calculated using the first equation, new values of <span class="math notranslate nohighlight">\(C_i\)</span> are then calculated using the second equation, and the process is iterated until the differences between successive values are sufficiently small.</p>
</section>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="Running_a_REST_simulation.html" title="Previous document">Replica Exchange Solute Tempering (REST)</a>
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.svg" alt="Logo" />
    
    <h1 class="logo logo-name">OpenMM Cookbook & Tutorials</h1>
    
  </a>
</p>











<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><div class="navigation-scrollbox">
    <div class="nav-toctree">
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../cookbook.html">The OpenMM Cookbook</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../tutorials.html">The OpenMM Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#getting-started">Getting Started</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../tutorials.html#beyond-the-basics">Beyond the Basics</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Alchemical_free_energy_calculations.html">Alchemical Free Energy Calculations</a></li>
<li class="toctree-l3"><a class="reference internal" href="coarse_grained_polymer.html">Implementing a Coarse-Grained Polymer Force Field</a></li>
<li class="toctree-l3"><a class="reference internal" href="nuclear_quantum_effects.html">Nuclear Quantum Effects With RPMD and adQTB</a></li>
<li class="toctree-l3"><a class="reference internal" href="Running_a_REST_simulation.html">Replica Exchange Solute Tempering (REST)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Umbrella Sampling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Theory">Theory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Umbrella-sampling-simulations">Umbrella sampling simulations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#System">System</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-1-—-Setting-up-the-windows-with-SMD">Step 1 — Setting up the windows with SMD</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-2-—-Running-the-windows">Step 2 — Running the windows</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-3-—-Analysis-—-compute-the-PMF">Step 3 — Analysis — compute the PMF</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Next-steps">Next steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="#References">References</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Appendix">Appendix</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
    
    <ul class="extra-nav-links">
        
        <li class="toctree-l1">
            <a href="https://openmm.org">
                OpenMM.org
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://docs.openmm.org/latest/userguide/">
                User's Manual
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://docs.openmm.org/latest/developerguide/">
                Developer Guide
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://docs.openmm.org/latest/api-c++/">
                C++ API reference
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://docs.openmm.org/latest/api-python/">
                Python API reference
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://github.com/openmm/openmm">
                GitHub
            </a>
        </li>
        
    </ul>
    
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, The OpenMM Contributors.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../_sources/notebooks/tutorials/umbrella_sampling.ipynb.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>