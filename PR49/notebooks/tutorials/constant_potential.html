<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Simulating Conductive Electrodes with the Constant Potential Method &#8212; OpenMM Cookbook &amp; Tutorials PR49 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=a0d4cc31" />
    <link rel="stylesheet" type="text/css" href="../../_static/nbsphinx-code-cells.css?v=2aa19091" />
    <link rel="stylesheet" type="text/css" href="../../_static/notebooks.css?v=9b8a9a20" />
    <script src="../../_static/documentation_options.js?v=f46d690a"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Umbrella Sampling" href="umbrella_sampling.html" />
    <link rel="prev" title="Replica Exchange Solute Tempering (REST)" href="Running_a_REST_simulation.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="nbsphinx-prolog">
    <a href="constant_potential.ipynb">Download Notebook</a>
    <a href="https://github.com/openmm/openmm-cookbook/blob/main/notebooks/tutorials/constant_potential.ipynb">View in GitHub</a>
    <a href="https://colab.research.google.com/github/openmm/openmm-cookbook/blob/gh-pages/PR49/colab/notebooks/tutorials/constant_potential.ipynb">Open in Google Colab</a>
</div><span class="target" id="index-0"></span><section id="Simulating-Conductive-Electrodes-with-the-Constant-Potential-Method">
<h1>Simulating Conductive Electrodes with the Constant Potential Method<a class="headerlink" href="#Simulating-Conductive-Electrodes-with-the-Constant-Potential-Method" title="Link to this heading">¶</a></h1>
<p>The constant potential molecular dynamics method is an approach for simulating conductive materials with delocalized charges, and maintaining them at prescribed electric potentials. In constant potential simulations, the charges on a prescribed set of particles (those belonging to the conductive material, or the “electrode particles”) are allowed to fluctuate as they interact with other particles in the system. This is useful for studying various kinds of electrochemical systems, <em>e.g.</em>, the
electrode-electrolyte interface in a parallel plate capacitor. In this tutorial, we will show how to set up a constant potential simulation using OpenMM’s implementation of this method. Specifically, we will use a capacitor system described in <a class="reference internal" href="#References"><span class="std std-ref">Ref. 1</span></a>, with an aqueous NaCl electrolyte sandwiched between two Au electrodes:</p>
<p><img alt="2f7d0794ab294095910f62283eea8965" class="no-scaled-link" src="../../_images/constant_potential_1.png" style="width: 800px;" /></p>
<section id="Theory">
<h2>Theory<a class="headerlink" href="#Theory" title="Link to this heading">¶</a></h2>
<p>A full exposition of the theory behind constant potential simulations is beyond the scope of this tutorial, but it is useful to be acquainted with the basics before getting started. In ordinary molecular simulations with fixed charges, we wish to sample configurations <span class="math notranslate nohighlight">\(\mathbf{r}^N\)</span> of <span class="math notranslate nohighlight">\(N\)</span> particles based on some potential energy function <span class="math notranslate nohighlight">\(U(\mathbf{r}^N)\)</span>. In the constant potential approach, some number <span class="math notranslate nohighlight">\(M\)</span> of particles are allowed to have varying charges, so that we
have <span class="math notranslate nohighlight">\(U(\mathbf{r}^N,\mathbf{q}^M)\)</span>. The commonly used method implemented by OpenMM for constant potential simulations uses a Born-Oppenheimer-like approach in which <span class="math notranslate nohighlight">\(\mathbf{q}^M\)</span> is chosen at every step to minimize <span class="math notranslate nohighlight">\(U\)</span> for the given <span class="math notranslate nohighlight">\(\mathbf{r}^N\)</span>. Since electrostatic interactions can be treated with Coulomb’s law, <span class="math notranslate nohighlight">\(U\)</span> is quadratic in the <span class="math notranslate nohighlight">\(\mathbf{q}^M\)</span>, and minimizing it is equivalent to solving a linear system.</p>
<p>Actually computing the coefficients of this system, which are functions of the particle positions, is more complex. For parallel plate capacitor geometries like the one shown above, the system effectively has periodic boundary conditions in the plane of the electrodes, but is non-periodic in the direction normal to their surfaces.</p>
<p><img alt="ed293ee63ef34fe5b8cef1c15e69a0a4" class="no-scaled-link" src="../../_images/constant_potential_2.png" style="width: 800px;" /></p>
<p>There are a few options for using periodic boundary conditions in all three dimensions so that standard tools for computing the electrostatic interactions, such as the particle mesh Ewald method, can be employed. Leaving empty space between periodic images introduces various complications, since this effectively creates a pair of dissimilar capacitors, one containing an electrolyte material of interest, and another containing vacuum. Another option is a double cell geometry, with each periodic
image containing the capacitor system of interest and a reflected copy of it. This keeps the net potential difference across the simulation cell, and its net dipole moment, zero:</p>
<p><img alt="b7f6897caefa416a8f436eaf8cd68ee4" class="no-scaled-link" src="../../_images/constant_potential_3.png" style="width: 800px;" /></p>
<p>The implementation in OpenMM supports such geometries, but they are more computationally expensive, requiring double the number of particles in the system of interest. In this tutorial, we show how to use the finite field method described in <a class="reference internal" href="#References"><span class="std std-ref">Ref. 2</span></a>, in which only a single copy of the system is needed, and an external electric field is applied to all charges in the system to maintain the desired electric potential difference across the periodic box:</p>
<p><img alt="009e29af2a73489aa577b00b1910a043" class="no-scaled-link" src="../../_images/constant_potential_4.png" style="width: 800px;" /></p>
<p>There are many more details that this tutorial will not explore, but the reader is referred to <a class="reference internal" href="#References"><span class="std std-ref">Refs. 1-3</span></a> for more information about the theory, as well as to the <a class="reference external" href="https://docs.openmm.org/latest/userguide/theory/02_standard_forces.html#constantpotentialforce">user guide</a> for the details of the specific implementation in OpenMM.</p>
</section>
<section id="Setting-Parameters">
<h2>Setting Parameters<a class="headerlink" href="#Setting-Parameters" title="Link to this heading">¶</a></h2>
<p>To begin writing a script implementing the capacitor system in OpenMM, we first import the required packages:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">openmm</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">openmm.app</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">openmm.unit</span>
</pre></div>
</div>
</div>
<p>We can now define various parameters for the simulation. An appropriate geometry, force field, and parameters for a constant potential simulation will depend on the system you are interested in; here, we use <a class="reference external" href="https://gitlab.com/ampere2/scalfi_jcp_153_174704_2020/-/blob/8bdb701c9ab7a9d914d1efce7efd90c08e5432b0/typical_input_files/gold_NaCl1M/runtime.inpt">data provided with</a> the work of <a class="reference internal" href="#References"><span class="std std-ref">Ref. 1</span></a>. Generic interaction-related parameters can be set in force field files that we
will load later, but we will specify constant potential-related parameters as well as integration settings directly in the script.</p>
<p>We begin with the potential we want to place across the plates of the capacitor:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">VOLT</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">volt</span> <span class="o">*</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">AVOGADRO_CONSTANT_NA</span>
<span class="n">POTENTIAL</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">VOLT</span>
</pre></div>
</div>
</div>
<p>Note that we multiply OpenMM’s <code class="docutils literal notranslate"><span class="pre">volt</span></code> unit by <code class="docutils literal notranslate"><span class="pre">AVOGADRO_CONSTANT_NA</span></code>. This is because, in OpenMM’s default unit system, which uses <span class="math notranslate nohighlight">\(\mathrm{kJ/mol}\)</span> for energy, and the elementary charge <span class="math notranslate nohighlight">\(\mathrm{e}\)</span> for charge, the units of electric potential are <span class="math notranslate nohighlight">\(\mathrm{kJ/mol/e}\)</span>. OpenMM’s <code class="docutils literal notranslate"><span class="pre">volt</span></code> unit is missing the factor of <span class="math notranslate nohighlight">\(1/\mathrm{mol}\)</span>, so multiplying by the Avogadro constant accounts for it. For more information, see the <a class="reference internal" href="building_systems.html#Dimensionless-Units"><span class="std std-ref">discussion on units in the Building Systems from
Scratch introductory tutorial</span></a>.</p>
<p>Next, we define a parameter (commonly referred to as <span class="math notranslate nohighlight">\(\eta\)</span> in the constant potential literature) that controls the width of the distributions of charges on electrode atoms in the simulation. The constant potential method as commonly formulated (and as implemented in OpenMM) uses Gaussian charge distributions, rather than point charges, for electrode atoms, since it is necessary to account for the self-interaction energy of the electrode charges to obtain a well-defined minimum to the
potential energy with respect to the charges. The resulting functional form of the electrostatic interactions is detailed in the <a class="reference external" href="https://docs.openmm.org/latest/userguide/theory/02_standard_forces.html#constantpotentialforce">theory section of the user guide</a>.</p>
<p>For the matter of choosing an appropriate value of <span class="math notranslate nohighlight">\(\eta\)</span> for a given system, the reader is referred to <a class="reference internal" href="#References"><span class="std std-ref">Ref. 4</span></a>. Here, we simply use the value chosen in <a class="reference internal" href="#References"><span class="std std-ref">Ref. 1</span></a>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ETA</span> <span class="o">=</span> <span class="mf">0.955234657</span> <span class="o">/</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">bohr</span>
</pre></div>
</div>
</div>
<p>OpenMM’s constant potential implementation supports the Thomas-Fermi model, a simple semiclassical approximation to account for screening in imperfect conductors (for details, refer again to <a class="reference internal" href="#References"><span class="std std-ref">Ref. 1</span></a>). This model requires a Thomas-Fermi length controlling the strength of the screening, and a volume per atom corresponding to the reciprocal of the atomic number density in the electrode material (sometimes referred to as a “Voronoi volume” in the literature).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">L_TF</span> <span class="o">=</span> <span class="mf">9.44863</span> <span class="o">*</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">bohr</span>
<span class="n">V_TF</span> <span class="o">=</span> <span class="mf">113.74173222606741</span> <span class="o">*</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">bohr</span> <span class="o">**</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
<p>Finally, we specify a cutoff distance for the nonbonded interactions and set some standard parameters for integrating the system. Note that for the constant potential method, the cutoff distance should be large enough to avoid truncation artifacts in the interactions of the Gaussian charge distributions on the electrode atoms (see the <a class="reference external" href="https://docs.openmm.org/latest/userguide/theory/02_standard_forces.html#constantpotentialforce">theory section</a> of the user guide). For typical values of the
cutoff distance <span class="math notranslate nohighlight">\(\ge10\ \mathrm{Å}\)</span> and Gaussian parameter <span class="math notranslate nohighlight">\(\eta\approx 2/\mathrm{Å}\)</span>, this should not be an issue. For more details on choosing appropriate integration parameters, see the <a class="reference internal" href="simulation_parameters.html"><span class="doc">Selecting Values for Simulation Parameters</span></a> tutorial.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">R_CUT</span> <span class="o">=</span> <span class="mf">22.68</span> <span class="o">*</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">bohr</span> <span class="c1"># 12 Å</span>
<span class="n">TEMP</span> <span class="o">=</span> <span class="mf">298.0</span> <span class="o">*</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">kelvin</span>
<span class="n">FRICTION</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">picosecond</span>
<span class="n">STEP</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">femtosecond</span>
</pre></div>
</div>
</div>
</section>
<section id="Creating-the-System">
<h2>Creating the System<a class="headerlink" href="#Creating-the-System" title="Link to this heading">¶</a></h2>
<p>With all of the parameters defined, we can start building the OpenMM <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html">System</a> object. The constant potential method in OpenMM is implemented in the <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html">ConstantPotentialForce</a> class. To use it, we must add it to a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html">System</a> like any other
force, add particles with charges that would ordinarily be set in a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html">NonbondedForce</a>, and specify various constant potential-specific options that will be discussed below.</p>
<p>To make it easier to set up the simulation for this tutorial, we have converted the <a class="reference external" href="https://gitlab.com/ampere2/scalfi_jcp_153_174704_2020/-/blob/8bdb701c9ab7a9d914d1efce7efd90c08e5432b0/typical_input_files/gold_NaCl1M/data.inpt">data provided</a> with <a class="reference internal" href="#References"><span class="std std-ref">Ref. 1</span></a> into a PDB file included with the tutorial. We can load it to obtain a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.app.topology.Topology.html">Topology</a> for the capacitor system, as well as initial
coordinates for the simulation.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pdb</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">PDBFile</span><span class="p">(</span><span class="s2">&quot;constant_potential.pdb&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The PDB file is structured so as to arrange the atoms into four different chains. Since there are no <em>physical</em> chains in this system, this arrangement only serves to group atoms together in a convenient way. The first chain contains the water molecules, the second contains the ions, and the third and fourth contain the atoms in the negative and positive electrodes, respectively:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>REMARK   1 CREATED WITH OPENMM 8.4, 2025-11-21
CRYST1   36.630   36.630  107.952  90.00  90.00  90.00 P 1           1
HETATM    1  O   HOH A   1      11.142   0.802  28.170  1.00  0.00           O
HETATM    2  H1  HOH A   1      11.545  -0.100  28.325  1.00  0.00           H
HETATM    3  H2  HOH A   1      11.052   1.281  29.044  1.00  0.00           H
...
HETATM 6478  O   HOH A2160      17.737  27.459  36.530  1.00  0.00           O
HETATM 6479  H1  HOH A2160      18.729  27.349  36.463  1.00  0.00           H
HETATM 6480  H2  HOH A2160      17.524  28.388  36.833  1.00  0.00           H
TER    6481      HOH A2160
HETATM 6482 NA    NA B   1       7.994  30.504  24.998  1.00  0.00          Na
HETATM 6483 CL    CL B   2      21.001  26.555  32.728  1.00  0.00          Cl
...
HETATM 6558 NA    NA B  77       0.677  11.774  51.823  1.00  0.00          Na
HETATM 6559 CL    CL B  78      34.536   2.353  48.278  1.00  0.00          Cl
TER    6560       CL B  78
HETATM 6561 AU    AU C   1       0.000   0.000   3.911  1.00  0.00          Au
...
HETATM 8180 AU    AU C1620      34.595  34.595  20.191  1.00  0.00          Au
TER    8181       AU C1620
HETATM 8182 AU    AU D   1       0.000   0.000  72.895  1.00  0.00          Au
...
HETATM 9801 AU    AU D1620      34.595  34.595  89.175  1.00  0.00          Au
TER    9802       AU D1620
END
</pre></div>
</div>
<p>Although it will be useful in this tutorial, such a grouping is not required to use the constant potential method in OpenMM. If you are designing your own simulation setup, you may find it convenient to structure your topology differently; what makes the most sense will vary from problem to problem.</p>
<p>To create a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html">System</a>, then, we need a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.app.forcefield.ForceField.html">ForceField</a> to assign interaction parameters. <a class="reference internal" href="#References"><span class="std std-ref">Ref. 1</span></a> uses SPC/E water, so we will use a force field file for SPC/E, <code class="docutils literal notranslate"><span class="pre">amber19/spce.xml</span></code>, that is distributed with OpenMM and also contains parameters for NaCl. (These are different from the parameters chosen in <a class="reference internal" href="#References"><span class="std std-ref">Ref.
1</span></a>, so its results will not be exactly reproduced here, but the parameters are suitable for illustrative purposes.) This leaves the Au atoms, which we can write a simple force field file to provide the Lennard-Jones parameters from <a class="reference internal" href="#References"><span class="std std-ref">Ref. 1</span></a> for.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">cat</span> constant_potential_example_gold.xml
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;ForceField&gt;
    &lt;AtomTypes&gt;
        &lt;Type name=&#34;Au&#34; class=&#34;Au&#34; element=&#34;Au&#34; mass=&#34;0&#34;/&gt;
    &lt;/AtomTypes&gt;
    &lt;Residues&gt;
        &lt;Residue name=&#34;AU&#34;&gt;
            &lt;Atom name=&#34;AU&#34; type=&#34;Au&#34; /&gt;
        &lt;/Residue&gt;
    &lt;/Residues&gt;
    &lt;NonbondedForce coulomb14scale=&#34;0.8333333333333334&#34; lj14scale=&#34;0.5&#34;&gt;
        &lt;Atom type=&#34;Au&#34; charge=&#34;0&#34; sigma=&#34;0.2951&#34; epsilon=&#34;22.13336&#34; /&gt;
    &lt;/NonbondedForce&gt;
&lt;/ForceField&gt;
</pre></div></div>
</div>
<p>We will not discuss OpenMM’s force field file format here; for a detailed description, see the <a class="reference external" href="https://docs.openmm.org/latest/userguide/application/06_creating_ffs.html">user guide</a>, and for a more complex but introductory example of building such a file, see the <a class="reference internal" href="coarse_grained_polymer.html"><span class="doc">Implementing a Coarse-Grained Polymer Force Field</span></a> tutorial. Here, we only need to define one atom type that will be applied to all of the Au atoms, define a residue template matching a single Au
atom (since each Au atom in the PDB file is in its own residue), and define Lennard-Jones parameters for Au. (The <code class="docutils literal notranslate"><span class="pre">coulomb14scale</span></code> and <code class="docutils literal notranslate"><span class="pre">lj14scale</span></code> parameters are set to match those in <code class="docutils literal notranslate"><span class="pre">amber19/spce.xml</span></code> but are irrelevant to our system as it contains only isolated atoms and rigid molecules.) Note that:</p>
<ul class="simple">
<li><p>We have set the masses of all electrode atoms to zero, which fixes them in place. This is consistent with the simulation in the study of <a class="reference internal" href="#References"><span class="std std-ref">Ref. 1</span></a>, but it is not a requirement for the use of the constant potential method in OpenMM. Some important notes for using non-rigid electrodes are provided at the end of this tutorial.</p></li>
<li><p>Here, we have set the charge on each Au atom to zero, but this value will be ignored once we set it in a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html">ConstantPotentialForce</a> that we will create later; the true charges will be calculated by solving the constant potential equations at every simulation timestep and so will fluctuate over the course of the simulation.</p></li>
</ul>
<p>We can now create a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.app.forcefield.ForceField.html">ForceField</a> and a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html">System</a> straightforwardly:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">force_field</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">ForceField</span><span class="p">(</span><span class="s2">&quot;amber19/spce.xml&quot;</span><span class="p">,</span> <span class="s2">&quot;constant_potential_example_gold.xml&quot;</span><span class="p">)</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">force_field</span><span class="o">.</span><span class="n">createSystem</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">topology</span><span class="p">,</span> <span class="n">nonbondedMethod</span><span class="o">=</span><span class="n">openmm</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">CutoffPeriodic</span><span class="p">,</span> <span class="n">nonbondedCutoff</span><span class="o">=</span><span class="n">R_CUT</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Even though our <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html">System</a> should contain some charged particles on account of the water and ions within, such that we might ordinarily want to use <code class="docutils literal notranslate"><span class="pre">PME</span></code> for the <code class="docutils literal notranslate"><span class="pre">nonbondedMethod</span></code>, here we use <code class="docutils literal notranslate"><span class="pre">CutoffPeriodic</span></code> for reasons that will be explained in the next section.</p>
</section>
<section id="Setting-up-the-ConstantPotentialForce">
<h2>Setting up the ConstantPotentialForce<a class="headerlink" href="#Setting-up-the-ConstantPotentialForce" title="Link to this heading">¶</a></h2>
<p>OpenMM’s standard force field-based mechanism will create a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html">NonbondedForce</a> with parameters for both electrostatic and Lennard-Jones interactions between the particles in a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html">System</a>. To run a constant potential simulation, we need all of the electrostatic parameters to be specified in a
<a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html">ConstantPotentialForce</a> instead. To do this, we can write a function that will identify the <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html">NonbondedForce</a> in a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html">System</a>, add its charges to a newly created
<a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html">ConstantPotentialForce</a>, and zero the charges in the <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html">NonbondedForce</a> (so that the electrostatic interactions between particles with fixed charges will not be computed twice).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">add_constant_potential</span><span class="p">(</span><span class="n">system</span><span class="p">):</span>
    <span class="c1"># Extract exactly one NonbondedForce from the System.</span>
    <span class="n">lj</span><span class="p">,</span> <span class="o">=</span> <span class="p">(</span><span class="n">force</span> <span class="k">for</span> <span class="n">force</span> <span class="ow">in</span> <span class="n">system</span><span class="o">.</span><span class="n">getForces</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">force</span><span class="p">,</span> <span class="n">openmm</span><span class="o">.</span><span class="n">NonbondedForce</span><span class="p">))</span>

    <span class="c1"># Create a new ConstantPotentialForce and add it to the System.</span>
    <span class="n">conp</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">ConstantPotentialForce</span><span class="p">()</span>
    <span class="n">system</span><span class="o">.</span><span class="n">addForce</span><span class="p">(</span><span class="n">conp</span><span class="p">)</span>

    <span class="c1"># Process each particle in the NonbondedForce.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lj</span><span class="o">.</span><span class="n">getNumParticles</span><span class="p">()):</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="n">lj</span><span class="o">.</span><span class="n">getParticleParameters</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">lj</span><span class="o">.</span><span class="n">setParticleParameters</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">conp</span><span class="o">.</span><span class="n">addParticle</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

    <span class="c1"># Process each exception in the NonbondedForce.</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lj</span><span class="o">.</span><span class="n">getNumExceptions</span><span class="p">()):</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">qq</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="n">lj</span><span class="o">.</span><span class="n">getExceptionParameters</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">lj</span><span class="o">.</span><span class="n">setExceptionParameters</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">conp</span><span class="o">.</span><span class="n">addException</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">qq</span><span class="p">)</span>

    <span class="c1"># Copy the nonbonded cutoff distance to the ConstantPotentialForce.</span>
    <span class="n">conp</span><span class="o">.</span><span class="n">setCutoffDistance</span><span class="p">(</span><span class="n">lj</span><span class="o">.</span><span class="n">getCutoffDistance</span><span class="p">())</span>

    <span class="c1"># We will need to do some additional setup on the ConstantPotentialForce, so return it.</span>
    <span class="k">return</span> <span class="n">conp</span>
</pre></div>
</div>
</div>
<p>As shown in this relatively straightforward function, adding a particle to a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html">ConstantPotentialForce</a> is as simple as calling <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html#openmm.openmm.ConstantPotentialForce.addParticle">ConstantPotentialForce.addParticle()</a> and providing the particle charge. Since it does not compute Lennard-Jones or other kinds
of interactions, this is the only parameter accepted. Exceptions for particles bonded to each other can be added with <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html#openmm.openmm.ConstantPotentialForce.addException">ConstantPotentialForce.addException()</a>.</p>
<p>We can thus convert our system into a constant potential-enabled version, and get a reference to the newly added force:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">conp</span> <span class="o">=</span> <span class="n">add_constant_potential</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>We also must specify which particles belong to conductive electrodes and should thus have fluctuating rather than fixed charges. We can do this with <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html#openmm.openmm.ConstantPotentialForce.addElectrode">ConstantPotentialForce.addElectrode()</a>, which accepts a list of particle indices. Since the third and fourth chains in the topology contain the Au atoms in each electrode, respectively, we can extract
the appropriate indices. In addition, <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html#openmm.openmm.ConstantPotentialForce.addElectrode">addElectrode()</a> takes the potential at which to hold the electrode, a Gaussian width parameter that is the reciprocal of the commonly used <span class="math notranslate nohighlight">\(\eta\)</span> value, and a Thomas-Fermi parameter with units of reciprocal width that should be set to the square of the Thomas-Fermi length divided by the atomic volume. (To
simulate a perfect conductor and eschew the Thomas-Fermi model entirely, set this parameter to zero.) In this example, for the potential difference <span class="math notranslate nohighlight">\(\Delta\psi\)</span> we want to apply, we set the potential of one electrode to <span class="math notranslate nohighlight">\(-\Delta\psi/2\)</span> and that of the other to <span class="math notranslate nohighlight">\(\Delta\psi/2\)</span>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">chains</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">chains</span><span class="p">())</span>
<span class="n">conp</span><span class="o">.</span><span class="n">addElectrode</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">chains</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">()],</span> <span class="o">-</span><span class="n">POTENTIAL</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">ETA</span><span class="p">,</span> <span class="n">L_TF</span> <span class="o">*</span> <span class="n">L_TF</span> <span class="o">/</span> <span class="n">V_TF</span><span class="p">)</span>
<span class="n">conp</span><span class="o">.</span><span class="n">addElectrode</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">chains</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">()],</span> <span class="n">POTENTIAL</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">ETA</span><span class="p">,</span> <span class="n">L_TF</span> <span class="o">*</span> <span class="n">L_TF</span> <span class="o">/</span> <span class="n">V_TF</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>This method of using the <code class="docutils literal notranslate"><span class="pre">add_constant_potential()</span></code> function given here, then specifying the appropriate electrodes, should be adaptable to your own constant potential simulations. A few important notes are in order:</p>
<ul class="simple">
<li><p>Each atom may belong to at most one electrode. Note, however, that all “electrodes” added to a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html">ConstantPotentialForce</a> are permitted to exchange charge freely with each other, and the concept of an “electrode” in the OpenMM implementation only serves to group electrode particles with similar parameters together.</p></li>
<li><p>Though only some atoms in this example belong to an electrode, it is still always necessary to add <em>every</em> particle to the <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html">ConstantPotentialForce</a>, and zero <em>each</em> charge in the <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html">NonbondedForce</a>. When using
<a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html">ConstantPotentialForce</a> in a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html">System</a>, <em>all</em> Coulombic interactions must be accounted for by a single <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html">ConstantPotentialForce</a>. Setting charges in more than one
<a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html">ConstantPotentialForce</a>, or any other force like a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html">NonbondedForce</a> or <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.AmoebaMultipoleForce.html">AmoebaMultipoleForce</a>, will yield incorrect simulation results, since
<a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html">ConstantPotentialForce</a> needs to account for the charges on every particle to properly solve for the charge distributions in the electrodes.</p></li>
<li><p>Since no non-zero charges remain in the <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html">NonbondedForce</a>, we have used <code class="docutils literal notranslate"><span class="pre">CutoffPeriodic</span></code> rather than <code class="docutils literal notranslate"><span class="pre">PME</span></code> for the nonbonded interaction calculation method when creating the system. The <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html">ConstantPotentialForce</a> always uses particle mesh Ewald to compute interactions, so there is no option to control the
method it uses for computing interactions.</p></li>
</ul>
<section id="Constant-Potential-Specific-Options">
<h3>Constant Potential-Specific Options<a class="headerlink" href="#Constant-Potential-Specific-Options" title="Link to this heading">¶</a></h3>
<p>OpenMM’s implementation of constant potential offers two methods for solving for the electrode charges. The default conjugate gradient (CG) solver is applicable to all simulation configurations, but is an iterative method, requiring multiple evaluations of the derivatives of the energy with respect to the electrode per timestep. Thus, OpenMM also offers a matrix solver that precomputes the inverse of the coefficient matrix for the linear equations to be solved; this only requires a single
evaluation of the derivatives per timestep. However:</p>
<ul class="simple">
<li><p>Since the coefficients of this matrix are functions of the electrode atom positions, the matrix solver can only be used if all electrode atoms are fixed in place by zeroing their masses.</p></li>
<li><p>Inverting the matrix takes <span class="math notranslate nohighlight">\(\mathcal{O}(M^3)\)</span> time whenever a simulation is started or the electrode atom positions are adjusted, and the solver requires <span class="math notranslate nohighlight">\(\mathcal{O}(M^2)\)</span> space to store the inverse, where <span class="math notranslate nohighlight">\(M\)</span> is the number of electrode atoms.</p></li>
</ul>
<p>If you want to perform a simulation with non-rigid electrodes, you must use the default CG solver. Otherwise, the matrix solver may be faster for smaller systems, whereas the CG solver is typically faster above a certain system size threshold. This crossover point is dependent on the details of your system and the hardware that OpenMM is running on, so you should evaluate both solvers and choose the one with the best performance, or choose the CG solver if the matrix solver requires too much
memory. Here, we use the matrix solver, but again, this may not be the best choice for every system even if it is applicable here:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">conp</span><span class="o">.</span><span class="n">setConstantPotentialMethod</span><span class="p">(</span><span class="n">openmm</span><span class="o">.</span><span class="n">ConstantPotentialForce</span><span class="o">.</span><span class="n">Matrix</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Constant potential simulations are typically performed with a constraint of constant total charge. Both solvers in OpenMM’s implementation can enforce such a constraint:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">conp</span><span class="o">.</span><span class="n">setUseChargeConstraint</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>By default, the total charge of the system, which includes both the variable (electrode) and fixed (electrolyte) charges, will be constrained to zero when the charge constraint is enabled, but this can be controlled with <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html#openmm.openmm.ConstantPotentialForce.setChargeConstraintTarget">ConstantPotential.setChargeConstraintTarget()</a> if desired.</p>
<p>Finally, as we have mentioned <a class="reference internal" href="#Theory"><span class="std std-ref">above</span></a>, we want to set up a finite field constant potential simulation. Here, for the set of initial coordinates we will read in, the electrode with the higher potential has a larger displacement along the <span class="math notranslate nohighlight">\(z\)</span>-axis than that with the lower potential, so we set the electric field vector as follows:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">L_Z</span> <span class="o">=</span> <span class="n">pdb</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">getPeriodicBoxVectors</span><span class="p">()[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="n">conp</span><span class="o">.</span><span class="n">setExternalField</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">POTENTIAL</span> <span class="o">/</span> <span class="n">L_Z</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>If you have performed constant potential simulations <a class="reference external" href="https://docs.lammps.org/fix_electrode.html">in LAMMPS</a>, for instance, it is required to use exactly two electrodes, and space them apart along the <span class="math notranslate nohighlight">\(z\)</span>-axis: then the external electric field will be added automatically. The OpenMM implementation places no such restrictions on the geometry; the electrodes and electric field can be oriented in any way desired.</p>
<p>Finally, we add the forces to the system, set the periodic box vectors, create a Langevin integrator for temperature control, and create a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.app.simulation.Simulation.html">Simulation</a>:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">integrator</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">LangevinMiddleIntegrator</span><span class="p">(</span><span class="n">TEMP</span><span class="p">,</span> <span class="n">FRICTION</span><span class="p">,</span> <span class="n">STEP</span><span class="p">)</span>
<span class="n">simulation</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">topology</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">integrator</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="Running-the-Simulation">
<h2>Running the Simulation<a class="headerlink" href="#Running-the-Simulation" title="Link to this heading">¶</a></h2>
<p>We will now load some initial position coordinates for the simulation. Like the simulation parameters, these are adapted from the <a class="reference external" href="https://gitlab.com/ampere2/scalfi_jcp_153_174704_2020/-/blob/8bdb701c9ab7a9d914d1efce7efd90c08e5432b0/typical_input_files/gold_NaCl1M/data.inpt">data provided</a> with <a class="reference internal" href="#References"><span class="std std-ref">Ref. 1</span></a>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">simulation</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">setPositions</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The capacitance <span class="math notranslate nohighlight">\(C\)</span> of the system at the applied potential can be calculated from <span class="math notranslate nohighlight">\(Q=C\Delta\psi\)</span>, where <span class="math notranslate nohighlight">\(Q\)</span> is the charge on an electrode. We can write a custom reporter class (see the <a class="reference internal" href="loading_and_reporting.html#Writing-Custom-Reporters"><span class="std std-ref">Loading Input Files and Reporting Results</span></a> introductory tutorial for more information on custom reporters) to calculate the capacitance. Calling
<a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html#openmm.openmm.ConstantPotentialForce.getCharges">ConstantPotentialForce.getCharges()</a> with a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.Context.html">Context</a> will return the charges of all particles in the system. For those not part of an electrode, these will be the charges that were specified with
<a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html#openmm.openmm.ConstantPotentialForce.addParticle">ConstantPotentialForce.addParticle()</a>; otherwise, they will be the charges solved for by the selected constant potential solver.</p>
<p>Since we set up the system, we could have saved the indices and potentials we set and used them to retrieve the appropriate charges and calculate the potential. This is not necessary, however: we can use <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html#openmm.openmm.ConstantPotentialForce.getElectrodeParameters">ConstantPotentialForce.getElectrodeParameters()</a> to retrieve the indices of all particles in an electrode, the imposed potential, the
Gaussian width parameter, and the Thomas-Fermi scale parameter. This is what we have done in the reporter below.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CapacitanceReporter</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reportInterval</span><span class="p">,</span> <span class="n">conp</span><span class="p">,</span> <span class="n">i_electrode</span><span class="p">,</span> <span class="n">j_electrode</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reportInterval</span> <span class="o">=</span> <span class="n">reportInterval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conp</span> <span class="o">=</span> <span class="n">conp</span>

        <span class="c1"># Retrieve and save the atom indices and electrode potentials.</span>
        <span class="c1"># Ignore the Gaussian width and Thomas-Fermi parameters as these are unneeded.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_i_indices</span><span class="p">,</span> <span class="n">i_potential</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">conp</span><span class="o">.</span><span class="n">getElectrodeParameters</span><span class="p">(</span><span class="n">i_electrode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_j_indices</span><span class="p">,</span> <span class="n">j_potential</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">conp</span><span class="o">.</span><span class="n">getElectrodeParameters</span><span class="p">(</span><span class="n">j_electrode</span><span class="p">)</span>

        <span class="c1"># Calculate the potential difference between the electrodes.  Dividing by</span>
        <span class="c1"># AVOGADRO_CONSTANT_NA removes a factor of 1/mol present in OpenMM&#39;s units.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_potential</span> <span class="o">=</span> <span class="p">(</span><span class="n">j_potential</span> <span class="o">-</span> <span class="n">i_potential</span><span class="p">)</span> <span class="o">/</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">AVOGADRO_CONSTANT_NA</span>

        <span class="c1"># We will store a sum of capacitance values (per area) and number of samples, for computing an average.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_capacitance_sum</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">farad</span> <span class="o">/</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">nanometer</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_capacitance_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">describeNextReport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simulation</span><span class="p">):</span>
        <span class="c1"># Calculate the number of steps to the next report, if reports should happen at multiples of reportInterval steps.</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reportInterval</span> <span class="o">-</span> <span class="n">simulation</span><span class="o">.</span><span class="n">currentStep</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reportInterval</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="p">[])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simulation</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># Get all of the charges, and find the sum of the electrode charges.</span>
        <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conp</span><span class="o">.</span><span class="n">getCharges</span><span class="p">(</span><span class="n">simulation</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>
        <span class="n">charge_i</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">charges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i_indices</span><span class="p">])</span>
        <span class="n">charge_j</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">charges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_j_indices</span><span class="p">])</span>

        <span class="c1"># The charge on each electrode should be equal and opposite, so the difference will be</span>
        <span class="c1"># twice the charge value we are looking for.  Dividing by the potential gives the capacitance,</span>
        <span class="c1"># and dividing by the cross-sectional area makes it independent of the size of the box.</span>
        <span class="n">capacitance</span> <span class="o">=</span> <span class="p">(</span><span class="n">charge_j</span> <span class="o">-</span> <span class="n">charge_i</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_potential</span><span class="p">)</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">getPeriodicBoxVectors</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">state</span><span class="o">.</span><span class="n">getPeriodicBoxVectors</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_capacitance_sum</span> <span class="o">+=</span> <span class="n">capacitance</span> <span class="o">/</span> <span class="n">area</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_capacitance_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">capacitance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_capacitance_sum</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_capacitance_count</span>
</pre></div>
</div>
</div>
<p>We can now run some equilibration steps, add the reporter, and take some samples to estimate the capacitance. The full simulation may take a few minutes to run on a GPU, or several times longer if OpenMM is using CPUs.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">simulation</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>

<span class="n">reporter</span> <span class="o">=</span> <span class="n">CapacitanceReporter</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">conp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">reporters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reporter</span><span class="p">)</span>

<span class="n">simulation</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The result obtained from OpenMM should be similar to the value of <span class="math notranslate nohighlight">\(0.798\ \mathrm{\mu F/cm^2}\)</span> <a class="reference external" href="https://gitlab.com/ampere2/scalfi_jcp_153_174704_2020/-/blob/8bdb701c9ab7a9d914d1efce7efd90c08e5432b0/DATA_FIGURES/FIGURE3/panel_c">reported</a> by <a class="reference internal" href="#References"><span class="std std-ref">Ref. 1</span></a> for the selected Thomas-Fermi length of <span class="math notranslate nohighlight">\(5\ \mathrm{Å}\)</span>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">reporter</span><span class="o">.</span><span class="n">capacitance</span><span class="p">()</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">micro</span> <span class="o">*</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">farad</span> <span class="o">/</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">centimeter</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
0.799263015399996 uF/(cm**2)
</pre></div></div>
</div>
</section>
<section id="Notes-and-Troubleshooting">
<h2>Notes and Troubleshooting<a class="headerlink" href="#Notes-and-Troubleshooting" title="Link to this heading">¶</a></h2>
<p>In this tutorial, we have seen how to set up a constant potential simulation in OpenMM. The basic procedure, and considerations discussed above, should apply in general to any kind of system you want to simulate with the constant potential method. However, there are a few issues that did not arise in the example we replicated that you should nevertheless be aware of.</p>
<p>First, in this example, all electrode atoms were held fixed. You may want to run a simulation with non-rigid electrodes. This can be done by giving the electrode atoms non-zero masses (and ensuring that the interactions you have specified between them will stabilize the desired structure). You may want to fix an atom or layer of atoms in each electrode in place in this case, or add a <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.CMMotionRemover.html">CMMotionRemover</a>, to
prevent them from drifting through the periodic box. Here, we used the same fixed density for the electrolyte as <a class="reference internal" href="#References"><span class="std std-ref">Ref. 1</span></a>, but you may want to use a barostat to equlibrate your constant potential simulation at constant pressure and determine the optimal spacing between the electrodes to avoid placing the electrolyte under excess pressure or under tension. To do so, ensure first that you are using an anisotropic barostat like the
<a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.MonteCarloAnisotropicBarostat.html">MonteCarloAnisotropicBarostat</a>. For finite field simulations, you will need to update the electric field strength whenever the box size changes. This can be done by calling <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html#openmm.openmm.ConstantPotentialForce.setExternalField">ConstantPotentialForce.setExternalField()</a> at the same interval as
the update interval for the barostat, dividing the desired potential difference by the current width of the box, then calling <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html#openmm.openmm.ConstantPotentialForce.updateParametersInContext">ConstantPotentialForce.updateParametersInContext()</a> if the external field changed to apply this change to the simulation.</p>
<p>Second, if you are using the conjugate gradient solver, you may wish or need to adjust its convergence tolerance. This can be done with <a class="reference external" href="https://docs.openmm.org/latest/api-python/generated/openmm.openmm.ConstantPotentialForce.html#openmm.openmm.ConstantPotentialForce.setCGErrorTolerance">ConstantPotentialForce.setCGErrorTolerance()</a>. The default is <span class="math notranslate nohighlight">\(10^{-4}\ \mathrm{kJ/mol/e}\)</span>, or approximately <span class="math notranslate nohighlight">\(1.04\ \mathrm{\mu V}\)</span>. For typical applied potentials on the order of
<span class="math notranslate nohighlight">\(1\ \mathrm{V}\)</span>, this accuracy should usually be sufficient. If the solver is unable to converge to the requested tolerance, OpenMM will raise an exception. This is usually caused by one of the following problems:</p>
<ul class="simple">
<li><p>There is a close overlap between an electrode atom and another atom, and either the initial positions that were set are unreasonable or the simulation has become unstable.</p></li>
<li><p>The Hessian of the potential energy with respect to the electrode charges is not positive definite. This can occur if the Gaussian width parameters for the electrodes are too large; ensure that they are set to an appropriate value.</p></li>
<li><p>The tolerance is set too small and numerical issues are preventing convergence. Either increase the tolerance, or if you need the accuracy, switch from single precision to mixed or double precision if the OpenMM platform provides this option.</p></li>
</ul>
<p>For some more information about the CG solver including its built-in preconditioner, and information about using ConstantPotentialForce with polarizable force fields, consult the <a class="reference external" href="https://docs.openmm.org/latest/userguide/theory/02_standard_forces.html#constantpotentialforce">theory section</a> of the user guide.</p>
</section>
<section id="References">
<h2>References<a class="headerlink" href="#References" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://doi.org/10.1063/5.0028232">Scalfi, L., Dufils, T., Reeves, K. G., Rotenberg, B., and Salanne, M. A semiclassical Thomas–Fermi model to tune the metallicity of electrodes in molecular simulations. J. Chem. Phys. 153, 174704 (2020)</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1103/PhysRevLett.123.195501">Dufils, T., Jeanmairet, G., Rotenberg, B., Sprik, M., and Salanne, M. Simulating electrochemical systems by combining the finite field method with a constant potential electrode. Phys. Rev. Lett. 123, 195501 (2019)</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1039/C9CP06285H">Scalfi, L., Limmer, D. T., Coretti, A., Bonella, S., Madden, P. A., Salanne, M., and Rotenberg, B. Charge fluctuations from molecular simulations in the constant-potential ensemble. Phys. Chem. Chem. Phys., 22, 10480 (2020)</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1063/1.2464084">Reed, S. K., Lanning, O. J., and Madden, P. A. Electrochemical interface between an ionic liquid and a model metallic electrode. J. Chem. Phys. 126, 084704 (2007)</a></p></li>
</ol>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="Running_a_REST_simulation.html" title="Previous document">Replica Exchange Solute Tempering (REST)</a>
        </li>
        <li>
          <a href="umbrella_sampling.html" title="Next document">Umbrella Sampling</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.svg" alt="Logo" />
    
    <h1 class="logo logo-name">OpenMM Cookbook & Tutorials</h1>
    
  </a>
</p>











<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><div class="navigation-scrollbox">
    <div class="nav-toctree">
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../cookbook.html">The OpenMM Cookbook</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../tutorials.html">The OpenMM Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#getting-started">Getting Started</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../tutorials.html#beyond-the-basics">Beyond the Basics</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Alchemical_free_energy_calculations.html">Alchemical Free Energy Calculations</a></li>
<li class="toctree-l3"><a class="reference internal" href="coarse_grained_polymer.html">Implementing a Coarse-Grained Polymer Force Field</a></li>
<li class="toctree-l3"><a class="reference internal" href="nuclear_quantum_effects.html">Nuclear Quantum Effects With RPMD and adQTB</a></li>
<li class="toctree-l3"><a class="reference internal" href="Running_a_REST_simulation.html">Replica Exchange Solute Tempering (REST)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Simulating Conductive Electrodes with the Constant Potential Method</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Theory">Theory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Setting-Parameters">Setting Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Creating-the-System">Creating the System</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Setting-up-the-ConstantPotentialForce">Setting up the ConstantPotentialForce</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Running-the-Simulation">Running the Simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Notes-and-Troubleshooting">Notes and Troubleshooting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#References">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="umbrella_sampling.html">Umbrella Sampling</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
    
    <ul class="extra-nav-links">
        
        <li class="toctree-l1">
            <a href="https://openmm.org">
                OpenMM.org
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://docs.openmm.org/latest/userguide/">
                User's Manual
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://docs.openmm.org/latest/developerguide/">
                Developer Guide
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://docs.openmm.org/latest/api-c++/">
                C++ API reference
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://docs.openmm.org/latest/api-python/">
                Python API reference
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://github.com/openmm/openmm">
                GitHub
            </a>
        </li>
        
    </ul>
    
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, The OpenMM Contributors.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../_sources/notebooks/tutorials/constant_potential.ipynb.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>