{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "6b971986",
   "metadata": {},
   "source": [
    "## Histone methyltransferase simulation with multisite Zn2+ structural ions\n",
    "\n",
    "*Simulating a protein with structural zinc ions using multisite ions.*\n",
    "\n",
    "This tutorial is described in [OpenMM 7](http://dx.doi.org/10.1371/journal.pcbi.1005659) publication.\n",
    "\n",
    "### Files\n",
    "\n",
    "- All input files can be found in [hkmt_zinc.zip](https://openmm.org/tutorials_/hkmt_zinc/files/hkmt_zinc.zip)\n",
    "\n",
    "### Introduction\n",
    "\n",
    "OpenMM allows users to model their systems using Amber and provide `prmtop`, and `inpcrd` files as input. This allows users more familiar with the Amber modeling environment to continue using their setup tools, while harnessing the speed and versatility of OpenMM. This also allows the use of non-standard force fields that have been published for use with Amber, such as metal ion models where dummy atoms are applied to mimic particular coordination geometries. Furthermore, this is facilitated by OpenMM's support for [Extra Particles](http://docs.openmm.org/latest/userguide/application/03_model_building_editing.html#adding-or-removing-extra-particles) which are particles that are not ordinary atoms, such as these metal dummy atoms, virtual sites in many water models, etc.\n",
    "\n",
    "This example illustrates the use of `tleap` from [AmberTools](http://ambermd.org/) to set up a simulation of the histone methyltransferase SETD2 (Uniprot: [Q9BYW2](http://www.uniprot.org/uniprot/Q9BYW2)), including three structural Zn2+ cations described with the tetrahedral Cationic Dummy Atom Approach (CADA: [DOI:10.1007/s008940050119](https://dx.doi.org/10.1007/s008940050119), [Pang lab](http://www.mayo.edu/research/labs/computer-aided-molecular-design/projects/zinc-protein-simulations-using-cationic-dummy-atom-cada-approach)).\n",
    "\n",
    "\n",
    "We begin from the [4H12](http://www.rcsb.org/pdb/explore.do?structureId=4h12) PDB file, add missing residues (only those in the middle of the chain) and missing heavy atoms using [PDBFixer](https://github.com/openmm/pdbfixer), and remove unwanted water and ligand residues using [MDTraj](http://mdtraj.org/). The CADA model requires particular naming of those residues, as well as deprotonation of the ligating cysteine sulfurs (i.e. their names are changed from CYS to CYM). Finally, `tleap` is run to add hydrogens, the Zn2+ dummy atoms and parametrize. We use the `ff99SBildn` force field and `znb.lib`, and `frcmod.zinc` files from the CADA model (downloaded from Pang lab). The `prmtop` and `inpcrd` files are saved for simulation in OpenMM.\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a8fed9d9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Download and unzip the inputfiles\n",
    "!wget https://openmm.org/tutorials_/hkmt_zinc/files/hkmt_zinc.zip\n",
    "!unzip -o hkmt_zinc.zip"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4b3f0a75",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pdbfixer import PDBFixer\n",
    "from openmm.app import PDBFile\n",
    "import mdtraj as md\n",
    "import os\n",
    "\n",
    "# clean up the original PDB file and add missing residues and heavy atoms\n",
    "fixer = PDBFixer('pdb4h12.ent')\n",
    "\n",
    "\n",
    "fixer.findMissingResidues()\n",
    "# only add missing residues in the middle of the chain, do not add terminal ones\n",
    "chains = list(fixer.topology.chains())\n",
    "keys = fixer.missingResidues.keys()\n",
    "missingResidues = dict()\n",
    "for key in keys:\n",
    "    chain = chains[key[0]]\n",
    "    if not (key[1] == 0 or key[1] == len(list(chain.residues()))):\n",
    "        missingResidues[key] = fixer.missingResidues[key]\n",
    "fixer.missingResidues = missingResidues\n",
    "\n",
    "fixer.findMissingAtoms()\n",
    "fixer.addMissingAtoms()\n",
    "\n",
    "PDBFile.writeFile(fixer.topology, fixer.positions, open('4h12_fixed.pdb', 'w'))\n",
    "\n",
    "# keep only protein and zinc ions\n",
    "traj = md.load('4h12_fixed.pdb')\n",
    "traj = traj.atom_slice(traj.top.select('(protein and not resname SAH) or resname ZN'))\n",
    "\n",
    "# implement changes necessary for the use of the dummy atom Zn2+ model\n",
    "# change residue name of the zincs from ZN to ZNB, and atom names from ZN to Zn\n",
    "for residue in traj.top.chain(1).residues:\n",
    "    residue.name = 'ZNB'\n",
    "for atom in traj.top.chain(1).atoms:\n",
    "    atom.name = 'Zn'\n",
    "\n",
    "# change name of cysteines coordinating zincs to CYM (deprotonated cysteine)\n",
    "for residue in traj.top.chain(0).residues:\n",
    "    if residue.index in [86, 92, 82, 69, 54, 52, 73, 184, 233, 238, 231]:\n",
    "        residue.name = 'CYM'\n",
    "\n",
    "traj.save('4h12_fixed_protein_zn_only.pdb')\n",
    "\n",
    "# save the tleap script to file\n",
    "with open('leaprc.setd2', 'w') as f:\n",
    "    f.write('''\n",
    "source oldff/leaprc.ff99SBildn\n",
    "addAtomTypes { { \"DZ\" \"Zn\" \"sp3\" } { \"Zn\" \"Zn\" \"sp3\" } }\n",
    "loadOff znb.lib\n",
    "loadamberparams frcmod.zinc\n",
    "x = loadPdb 4h12_fixed_protein_zn_only.pdb\n",
    "addIons x Cl- 0\n",
    "solvateBox x TIP3PBOX 10.0\n",
    "savePdb x topology.pdb\n",
    "saveAmberParm x input.prmtop input.inpcrd\n",
    "quit\n",
    "''')\n",
    "\n",
    "# run tleap\n",
    "\n",
    "# if you have amber tools installed on your system you can uncomment and run this line\n",
    "#os.system('tleap -f leaprc.setd2')\n",
    "\n",
    "# we have included the output files that get produced: \n",
    "# input.inpcrd and input.prmtop"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c9805bb7",
   "metadata": {},
   "source": [
    "We load the `prmtop` and `inpcrd` files in, by creating `AmberPrmtopFile` and `AmberInpcrdFile` objects. Next, the `System` is created by calling the createSystem() method on the AmberPrmtopFile object. \n",
    "\n",
    "Next, the `LangevinIntegrator` and the `Simulation` are set up, using the topology from the AmberPrmtopFile and positions from the AmberInpcrdFile. In this example we will use the CUDA platform, with mixed precision. The simulation is energy minimized and equilibrated for 100 steps. Reporters are attached and the production simulation propagated for 50 ns."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "72615e2c",
   "metadata": {},
   "outputs": [],
   "source": [
    "from openmm import app\n",
    "import openmm as mm\n",
    "from openmm import unit\n",
    "from sys import stdout\n",
    "\n",
    "# load in Amber input files\n",
    "prmtop = app.AmberPrmtopFile('input.prmtop')\n",
    "inpcrd = app.AmberInpcrdFile('input.inpcrd')\n",
    "\n",
    "# prepare system and integrator\n",
    "system = prmtop.createSystem(nonbondedMethod=app.PME,\n",
    "    nonbondedCutoff=1.0*unit.nanometers, constraints=app.HBonds, rigidWater=True,\n",
    "    ewaldErrorTolerance=0.0005)\n",
    "integrator = mm.LangevinIntegrator(300*unit.kelvin, 1.0/unit.picoseconds,\n",
    "    2.0*unit.femtoseconds)\n",
    "integrator.setConstraintTolerance(0.00001)\n",
    "\n",
    "\n",
    "simulation = app.Simulation(prmtop.topology, system, integrator)\n",
    "    #properties)\n",
    "simulation.context.setPositions(inpcrd.positions)\n",
    "\n",
    "# minimize\n",
    "print('Minimizing...')\n",
    "simulation.minimizeEnergy()\n",
    "\n",
    "# equilibrate for 100 steps\n",
    "simulation.context.setVelocitiesToTemperature(300*unit.kelvin)\n",
    "print('Equilibrating...')\n",
    "simulation.step(100)\n",
    "\n",
    "# append reporters\n",
    "simulation.reporters.append(app.DCDReporter('trajectory.dcd', 1000))\n",
    "simulation.reporters.append(app.StateDataReporter(stdout, 1000, step=True,\n",
    "    potentialEnergy=True, temperature=True, progress=True, remainingTime=True,\n",
    "    speed=True, totalSteps=25000000, separator='\\t'))\n",
    "\n",
    "# run 50 ns of production simulation\n",
    "print('Running Production...')\n",
    "simulation.step(25000000)\n",
    "print('Done!')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c5e3244c",
   "metadata": {},
   "source": [
    "Finally, we perform a quick analysis of the trajectory. We examine the RMSD of all frames to the first frame, and the mean sulfur - zinc distances to check the stability of the metal centers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e15d7137",
   "metadata": {},
   "outputs": [],
   "source": [
    "import mdtraj as md\n",
    "import matplotlib\n",
    "matplotlib.use('Agg')\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "# load trajectory and remove solvent\n",
    "traj = md.load_dcd('trajectory.dcd', top='topology.pdb', stride=50)\n",
    "traj = traj.atom_slice(traj.top.select('protein or resname ZNB'))\n",
    "\n",
    "# calculate RMSD to first frame and plot figure\n",
    "rmsd = md.rmsd(traj, traj)\n",
    "\n",
    "plt.figure()\n",
    "plt.plot(rmsd)\n",
    "plt.title('RMSD to first frame')\n",
    "plt.xlabel('Frame (0.1 ns/frame)')\n",
    "plt.ylabel('RMSD (nm)')\n",
    "plt.savefig('rmsd.png', dpi=300)\n",
    "plt.close()\n",
    "\n",
    "# calculate mean sulfur - zinc distances for 3 metal centers and plot figure\n",
    "atom_pairs_1 = [[3904, 892], [3904, 917], [3904, 1136], [3904, 1180]]\n",
    "atom_pairs_2 = [[3909, 1136], [3909, 1336], [3909, 1392], [3909, 1470]]\n",
    "atom_pairs_3 = [[3914, 2982], [3914, 3733], [3914, 3763], [3914, 3815]]\n",
    "\n",
    "distances_1 = md.compute_distances(traj, atom_pairs_1)\n",
    "distances_1 = [np.mean(x) for x in distances_1]\n",
    "distances_2 = md.compute_distances(traj, atom_pairs_2)\n",
    "distances_2 = [np.mean(x) for x in distances_2]\n",
    "distances_3 = md.compute_distances(traj, atom_pairs_3)\n",
    "distances_3 = [np.mean(x) for x in distances_3]\n",
    "\n",
    "plt.figure()\n",
    "plt.plot(distances_1, label='Zn1')\n",
    "plt.plot(distances_2, label='Zn2')\n",
    "plt.plot(distances_3, label='Zn3')\n",
    "plt.title('Mean S - Zn distances')\n",
    "plt.xlabel('Frame (0.1 ns/frame)')\n",
    "plt.ylabel('Mean S - Zn distance (nm)')\n",
    "plt.legend()\n",
    "plt.savefig('zn_s_distances.png', dpi=300)\n",
    "plt.close()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4386b460",
   "metadata": {},
   "source": [
    "![RMSD](./rmsd.png)\n",
    "\n",
    "![zn_s_distances](./zn_s_distances.png)"
   ]
  }
 ],
 "metadata": {
  "required_files": [],
  "tags": [
	"tutorial"
   ],
  "kernelspec": {
   "display_name": "Python 3.9.13 ('openmm')",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.13"
  },
  "nbsphinx": {
   "execute": "never"
  },
  "vscode": {
   "interpreter": {
    "hash": "16b2d2c1789d035bceb6d775bd7ffc39b805c8f0529038638d98b11c7a85ade5"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
