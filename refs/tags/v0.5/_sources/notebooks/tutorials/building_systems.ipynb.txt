{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "1054112a-ef6a-453f-95eb-201452309108",
   "metadata": {},
   "source": [
    "# Building Systems from Scratch\n",
    "\n",
    "## Introduction\n",
    "\n",
    "The previous two tutorials in this series showed how to use OpenMM to set up simulations using existing inputs: either molecular structures along with predefined force fields, or parameterized input files for other molecular dynamics engines like Amber or CHARMM.  We also saw how to use the OpenMM Setup tool to automatically generate Python scripts to run OpenMM for cases like these.  This way of using OpenMM is most useful for setting up simulations of biomolecules, for example, and uses OpenMM's convenient [application layer](https://docs.openmm.org/latest/api-python/app.html) for assigning parameters to complex topologies.  However, for simpler systems, *e.g.*, Lennard-Jones fluid mixtures, model colloidal crystals, bead-spring polymers, or other simple coarse-grained models, you might not need the complexity of this layer, and may also prefer more control over how your simulation is set up.  Alternatively, you might want to inspect or modify the OpenMM System objects created by one of the methods discussed in the previous tutorials, or write your own library for building simulations.  For these use cases, you can work directly with OpenMM's [library layer](https://docs.openmm.org/latest/api-python/library.html).\n",
    "\n",
    "This tutorial shows how to use the library layer to build [System](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html) objects.  Since OpenMM Setup is geared towards generating scripts using predefined structures or force fields, we will not use it here.  Instead, we will show how to write a script from scratch to set up and run a simulation of a binary Lennard-Jones fluid mixture.  In particular, we will simulate a mixture of particles of two types, \"A\" and \"B\", with pairwise interactions governed by the Lennard-Jones potential, $$u_{ij}(r)=4\\epsilon_{ij}\\left(\\frac{\\sigma_{ij}^{12}}{r^{12}}-\\frac{\\sigma_{ij}^6}{r^6}\\right),$$  where $\\sigma_{ij}$ and $\\epsilon_{ij}$ for a pair of particle types are given from parameters $\\sigma_i$ and $\\epsilon_i$ for each particle type by the Lorentz-Berthelot mixing rules $\\sigma_{ij}=(\\sigma_i+\\sigma_j)/2$ and $\\epsilon_{ij}=\\sqrt{\\epsilon_i\\epsilon_j}$."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "44729721-6360-4480-9187-a20d942e6915",
   "metadata": {},
   "source": [
    "## Writing the Script\n",
    "\n",
    "To get started, we will import OpenMM:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "b119b208-d35e-42d6-b5ef-182c1efe6b61",
   "metadata": {},
   "outputs": [],
   "source": [
    "import openmm\n",
    "import openmm.app\n",
    "import openmm.unit"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d701b258-e9e3-4dc7-a9d9-4536ed7c8735",
   "metadata": {},
   "source": [
    "For this tutorial, we will use classes within their packages rather than importing all of them into the global scope like the OpenMM Setup-generated scripts do.\n",
    "\n",
    "We will also import some other packages that are not strictly necessary for interacting with OpenMM but will be useful for the tutorial:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "f7bf31b3-7196-48dc-a6ee-b49c4169da33",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d5d87349-4641-40b9-8329-640f493cc215",
   "metadata": {},
   "source": [
    "### Dimensionless Units\n",
    "\n",
    "We have seen in the previous tutorials that OpenMM uses a [default unit system](https://docs.openmm.org/latest/userguide/theory/01_introduction.html#units) with $\\mathrm{nm}$ for length, $\\mathrm{kJ/mol}$ for energy, $\\mathrm{ps}$ for time, *etc.*, but also provides a [units API](https://docs.openmm.org/latest/api-python/app.html#units) for [manipulating and converting between](https://docs.openmm.org/latest/userguide/library/05_languages_not_cpp.html#units-and-dimensional-analysis) units.  On the other hand, it is common in theoretical work, as well as simulation studies of simple model systems like Lennard-Jones fluids, to specify values of parameters relative to some fixed scales, *e.g.*, a length scale $\\sigma$, an energy scale $\\epsilon$, a time scale $\\tau$, *etc.*, rather than concrete units.  It is often convenient to omit these scales entirely and write, *e.g.*, a parameter like a density $\\rho=0.6\\sigma^{-3}$ in dimensionless form $\\rho^*=0.6$.  As long as a self-consistent set of reference scales is chosen, dimensionless values can be used throughout a calculation.\n",
    "\n",
    "Some care must be taken in order to do this in OpenMM.  Passing unitless values to OpenMM when it expects quantities with units causes them to be interpreted in its default unit system, whose length, energy, time, and mass ($\\mathrm{g/mol}$) scales are all consistent with each other, but whose temperature ($\\mathrm{K}$) and pressure ($\\mathrm{bar}$) scales are not.  Thus, it is better to still use OpenMM's units API, and explicitly define the scale factors needed to obtain a consistent set of units.  For length, mass, energy, and time, we can use the default units:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "6cd4b2dd-5c9c-4b13-bdae-d6695b1553a6",
   "metadata": {},
   "outputs": [],
   "source": [
    "length_scale = openmm.unit.nanometer\n",
    "mass_scale = openmm.unit.dalton\n",
    "energy_scale = openmm.unit.kilojoule_per_mole\n",
    "time_scale = openmm.unit.picosecond"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2550c265-fa25-439e-befa-7d1cd65ebf1a",
   "metadata": {},
   "source": [
    "(One may note that these cannot all be independent, but it turns out that $1\\ \\mathrm{kJ/mol}=1\\ (\\mathrm{g/mol})(\\mathrm{nm}^2/\\mathrm{ps}^2)$, so this set of units works.)  For pressure, we want an energy per volume, but if we try this with our current set of scales, OpenMM will not let the result be converted to other pressure units:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "93afc1d3-bda4-4f58-98f9-de9c93266a8c",
   "metadata": {
    "editable": true,
    "slideshow": {
     "slide_type": ""
    },
    "tags": [
     "raises-exception"
    ]
   },
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "Unit \"kilojoule/(nanometer**3*mole)\" is not compatible with Unit \"bar\".",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mTypeError\u001b[39m                                 Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[4]\u001b[39m\u001b[32m, line 1\u001b[39m\n\u001b[32m----> \u001b[39m\u001b[32m1\u001b[39m \u001b[43m(\u001b[49m\u001b[32;43m1.0\u001b[39;49m\u001b[43m \u001b[49m\u001b[43m*\u001b[49m\u001b[43m \u001b[49m\u001b[43menergy_scale\u001b[49m\u001b[43m \u001b[49m\u001b[43m/\u001b[49m\u001b[43m \u001b[49m\u001b[43mlength_scale\u001b[49m\u001b[43m \u001b[49m\u001b[43m*\u001b[49m\u001b[43m*\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m3\u001b[39;49m\u001b[43m)\u001b[49m\u001b[43m.\u001b[49m\u001b[43min_units_of\u001b[49m\u001b[43m(\u001b[49m\u001b[43mopenmm\u001b[49m\u001b[43m.\u001b[49m\u001b[43munit\u001b[49m\u001b[43m.\u001b[49m\u001b[43mbar\u001b[49m\u001b[43m)\u001b[49m\n",
      "\u001b[36mFile \u001b[39m\u001b[32m~/miniforge3/envs/ommcookbook/lib/python3.13/site-packages/openmm/unit/quantity.py:661\u001b[39m, in \u001b[36mQuantity.in_units_of\u001b[39m\u001b[34m(self, other_unit)\u001b[39m\n\u001b[32m    650\u001b[39m \u001b[38;5;250m\u001b[39m\u001b[33;03m\"\"\"\u001b[39;00m\n\u001b[32m    651\u001b[39m \u001b[33;03mReturns an equal Quantity expressed in different units.\u001b[39;00m\n\u001b[32m    652\u001b[39m \n\u001b[32m   (...)\u001b[39m\u001b[32m    658\u001b[39m \u001b[33;03m  and  result = value * factor when post_multiply is True\u001b[39;00m\n\u001b[32m    659\u001b[39m \u001b[33;03m\"\"\"\u001b[39;00m\n\u001b[32m    660\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28mself\u001b[39m.unit.is_compatible(other_unit):\n\u001b[32m--> \u001b[39m\u001b[32m661\u001b[39m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mTypeError\u001b[39;00m(\u001b[33m'\u001b[39m\u001b[33mUnit \u001b[39m\u001b[33m\"\u001b[39m\u001b[38;5;132;01m%s\u001b[39;00m\u001b[33m\"\u001b[39m\u001b[33m is not compatible with Unit \u001b[39m\u001b[33m\"\u001b[39m\u001b[38;5;132;01m%s\u001b[39;00m\u001b[33m\"\u001b[39m\u001b[33m.\u001b[39m\u001b[33m'\u001b[39m % (\u001b[38;5;28mself\u001b[39m.unit, other_unit))\n\u001b[32m    662\u001b[39m f = \u001b[38;5;28mself\u001b[39m.unit.conversion_factor_to(other_unit)\n\u001b[32m    663\u001b[39m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m._change_units_with_factor(other_unit, f)\n",
      "\u001b[31mTypeError\u001b[39m: Unit \"kilojoule/(nanometer**3*mole)\" is not compatible with Unit \"bar\"."
     ]
    }
   ],
   "source": [
    "(1.0 * energy_scale / length_scale ** 3).in_units_of(openmm.unit.bar)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7ff3839a-3342-466f-bd4b-165d2a87b968",
   "metadata": {},
   "source": [
    "The problem is the factor of $\\mathrm{1/mol}$ in the energy scale, which OpenMM will not automatically eliminate.  Since a mole is just a fixed quantity of something, we can divide by the constant `AVOGADRO_CONSTANT_NA` that OpenMM provides to remove this factor and obtain a pressure scale consistent with the other scales we have defined."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "7efd3ca6-b57e-441f-ba1a-523478c96c03",
   "metadata": {},
   "outputs": [],
   "source": [
    "press_scale = energy_scale / (length_scale ** 3 * openmm.unit.AVOGADRO_CONSTANT_NA)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d2b25de4-a939-47de-a4c5-7b4ade73f2bc",
   "metadata": {},
   "source": [
    "This quantity can now be converted to $\\mathrm{bar}$:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "a84f241f-6768-449a-acea-d3445d7fe7ec",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "16.60539067173847 bar"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "press_scale.in_units_of(openmm.unit.bar)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "05842d91-163f-4ca3-87ee-abebe07ac01b",
   "metadata": {},
   "source": [
    "Similarly, from an energy scale, we can get a temperature scale by dividing by Boltzmann's constant, which OpenMM provides as `BOLTZMANN_CONSTANT_kB`.  We must again also divide by the Avogadro constant to remove a factor of $\\mathrm{1/mol}$ from the energy scale:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "b2ffa577-b9aa-4c79-ab90-134576bb8d37",
   "metadata": {},
   "outputs": [],
   "source": [
    "temp_scale = energy_scale / (openmm.unit.BOLTZMANN_CONSTANT_kB * openmm.unit.AVOGADRO_CONSTANT_NA)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1bc001d9-470b-409d-b92e-2dac542db123",
   "metadata": {},
   "source": [
    "In $\\mathrm{K}$, this is:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "e41dbc53-7806-4d0d-8f53-177b450c703b",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "120.27235504272605 K"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "temp_scale.in_units_of(openmm.unit.kelvin)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "54691516-c2da-4bff-808c-e93d362d2a3f",
   "metadata": {},
   "source": [
    "### Simulation Parameters\n",
    "\n",
    "With all of these scale factors in place, we can now define the actual parameters for our simulation.  First, we set values for the number of particles of each type, a starting number density for the system, and particle masses:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "44087619-265a-4058-ab8b-68607dc5a83a",
   "metadata": {},
   "outputs": [],
   "source": [
    "N_A = 500\n",
    "N_B = 500\n",
    "\n",
    "rho = 0.6 / length_scale ** 3\n",
    "\n",
    "m_A = 1.0 * mass_scale\n",
    "m_B = 1.1 * mass_scale"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f75f416a-c3cd-4298-abb0-f7bc476ebfcd",
   "metadata": {},
   "source": [
    "These are all ordinary variables; OpenMM will not do anything special with them until we explicitly provide them, as we will show below.\n",
    "\n",
    "Next, we set some Lennard-Jones potential parameters.  We also define a cutoff distance $r_{\\mathrm{cut}}$ beyond which the potential will not be evaluated."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "67ccb61e-73a3-4005-8999-dab0de5fb982",
   "metadata": {},
   "outputs": [],
   "source": [
    "r_cut = 3.0 * length_scale\n",
    "\n",
    "sigma_A = 1.0 * length_scale\n",
    "sigma_B = 1.2 * length_scale\n",
    "\n",
    "epsilon_A = 1.0 * energy_scale\n",
    "epsilon_B = 1.3 * energy_scale"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "77dd1773-80a6-4e36-8186-8ff294681627",
   "metadata": {},
   "source": [
    "Finally, we define a pressure and temperature for the system, and thermostat parameters that will be used later:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "9c3b3892-ed8c-4e35-ac25-c945220976cd",
   "metadata": {},
   "outputs": [],
   "source": [
    "press = 2.0 * press_scale\n",
    "temp = 1.5 * temp_scale\n",
    "friction = 1.0 / time_scale\n",
    "step = 0.005 * time_scale"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "55b06c1d-d094-443e-bbb9-2887e0a77a37",
   "metadata": {},
   "source": [
    "### Creating the System\n",
    "\n",
    "We are now ready to set up the simulation proper.  In OpenMM, this begins with a [System](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html), which instead of generating from a ForceField or other input data as was done in the previous tutorials, we now create directly:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "dc2a5cf0-b127-407f-b9e5-858a2afccbb2",
   "metadata": {},
   "outputs": [],
   "source": [
    "system = openmm.System()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "37c47f01-7d25-400d-9495-1f6d1e0cce53",
   "metadata": {},
   "source": [
    "A System object stores basic information about particles in a system, such as their masses, any rigid constraints between particles, and any definitions of [virtual sites](https://docs.openmm.org/latest/userguide/theory/05_other_features.html#virtual-sites) (particles whose positions are computed based on positions of other particles, rather than integrated normally).  Details of the *interactions* between the particles are not stored directly in the System, but instead, inside of [Forces](https://docs.openmm.org/latest/api-python/library.html#forces) added to the System.\n",
    "\n",
    "We begin by setting the default size of the periodic box on the System with [System.setDefaultPeriodicBoxVectors()](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html#openmm.openmm.System.setDefaultPeriodicBoxVectors).  We will later add a barostat to control the pressure, so the box will be scaled during simulation, but as discussed in [the previous tutorial](loading_and_reporting.ipynb#Input-Files), OpenMM needs default vectors to set up a Context.  Here, we create a cubic box giving the specified initial number density `rho`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "2f9b82cb-72dc-48b7-907b-03939133890f",
   "metadata": {},
   "outputs": [],
   "source": [
    "L_box = ((N_A + N_B) / rho) ** (1 / 3)\n",
    "system.setDefaultPeriodicBoxVectors(openmm.Vec3(L_box, 0, 0), openmm.Vec3(0, L_box, 0), openmm.Vec3(0, 0, L_box))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e5a25f6d-bfc0-4a69-a3d0-49da79bb7dac",
   "metadata": {},
   "source": [
    "Note here that we use OpenMM's built-in [Vec3](https://docs.openmm.org/latest/api-python/generated/openmm.vec3.Vec3.html) class, which represents 3-dimensional vectors and can perform basic mathematical operations on them.  However, OpenMM functions that accept Vec3 instances can also accept other sequences like lists, tuples, or NumPy arrays.\n",
    "\n",
    "We now add particles to the System one by one with [System.addParticle()](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html#openmm.openmm.System.addParticle).  An OpenMM System has no direct concept of \"particle types\".  Instead, you can create the particles in any order you want, as long as you ensure that particle parameters set in Forces are ordered in the same way.  Here, we will treat the first `N_A` particles in the System as type A, and the next `N_B` particles as type B."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "0dcc6748-e7a5-429d-bb44-8e5f3dd4f9bd",
   "metadata": {},
   "outputs": [],
   "source": [
    "for i_A in range(N_A):\n",
    "    system.addParticle(m_A)\n",
    "for i_B in range(N_B):\n",
    "    system.addParticle(m_B)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1655ff48-6b87-49d0-98c8-01cc2438d1c4",
   "metadata": {},
   "source": [
    "addParticle() returns the index of the particle just added to the System, so if you wanted to add particles in a less obvious order, and keep track of the indices of particles of each type, for instance, OpenMM makes it easy to do so.\n",
    "\n",
    "Now we need to define the interactions between particles.  We want to apply a Lennard-Jones potential between particle pairs, with Lorentz-Berthelot mixing rules.  We could use any function of interparticle distances as a pair potential, since OpenMM provides a [CustomNonbondedForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.CustomNonbondedForce.html) that accepts arbitrary mathematical expressions as strings and compiles them into optimized kernels for computation.  However, the potential we want here is so common in simulations that OpenMM provides a built-in class, [NonbondedForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html), to handle it:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "062d7d95-4788-4773-b96b-89892231feb2",
   "metadata": {},
   "outputs": [],
   "source": [
    "lj = openmm.NonbondedForce()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5a7837f9-dd5a-4b53-8aa4-0948a341e3cc",
   "metadata": {},
   "source": [
    "By default, newly created NonbondedForce objects are set to NoCutoff mode, which means that they ignore periodic boundary conditions and compute the potential for every pair of particles in a simulation.  To only compute interactions within a fixed cutoff, using the minimum image convention to apply periodic boundary conditions, use the `CutoffPeriodic` option to [NonbondedForce.setNonbondedMethod()](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html#openmm.openmm.NonbondedForce.setNonbondedMethod), and call [NonbondedForce.setCutoffDistance()](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html#openmm.openmm.NonbondedForce.setCutoffDistance) to set the cutoff distance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "47f1b864-b115-42e5-86fe-e37df0ad95f3",
   "metadata": {},
   "outputs": [],
   "source": [
    "lj.setNonbondedMethod(openmm.NonbondedForce.CutoffPeriodic)\n",
    "lj.setCutoffDistance(r_cut)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b9d16ab1-f130-409a-8155-ad825fa89f73",
   "metadata": {},
   "source": [
    "The [theory section of the user guide](https://docs.openmm.org/latest/userguide/theory/02_standard_forces.html#lennard-jones-interaction) discusses a number of other options for computing these as well as Coulomb interactions with NonbondedForce.\n",
    "\n",
    "Next, we register particle parameters with the NonbondedForce.  We must call [NonbondedForce.addParticle()](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html#openmm.openmm.NonbondedForce.addParticle) for each particle in the System that we want to add the NonbondedForce to; each subsequent call sets parameters for each particle in the System in order.  Consistent with the order we added the particles to the System, then, we set Lennard-Jones parameters for every A particle first, followed by every B particle:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "2d470957-5cd4-49ce-9878-10dca9b13eb6",
   "metadata": {},
   "outputs": [],
   "source": [
    "for i_A in range(N_A):\n",
    "    lj.addParticle(0.0, sigma_A, epsilon_A)\n",
    "for i_B in range(N_B):\n",
    "    lj.addParticle(0.0, sigma_B, epsilon_B)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c6612261-1db5-49e6-83f5-c5a3dfeacc69",
   "metadata": {},
   "source": [
    "The first parameter to addParticle() is the electric charge.  If all charges are set to zero, as above, no Coulomb interactions will be computed by the NonbondedForce.\n",
    "\n",
    "Finally, to actually use our newly created NonbondedForce, we must add it to the System with [System.addForce()](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html#openmm.openmm.System.addForce):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "22152bf4-e95f-43b3-9bc4-c5b514ab073c",
   "metadata": {},
   "outputs": [],
   "source": [
    "system.addForce(lj);"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "08f6faa8-81cc-4bfd-8b9d-db56c2e40c6a",
   "metadata": {},
   "source": [
    "As in previous tutorials, we add a MonteCarloBarostat to the System for pressure control, and use a LangevinMiddleIntegrator for integration and temperature control:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "7f5b8b20-94c0-41c5-b852-4fa33101e538",
   "metadata": {},
   "outputs": [],
   "source": [
    "system.addForce(openmm.MonteCarloBarostat(press, temp))\n",
    "integrator = openmm.LangevinMiddleIntegrator(temp, friction, step)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f49430cc-4bfd-4b38-9dad-1fb0cec5177e",
   "metadata": {},
   "source": [
    "### Creating the Simulation\n",
    "\n",
    "We have now prepared a System and an Integrator for our simulation.  Recall that in previous tutorials, we created a [Simulation](https://docs.openmm.org/latest/api-python/generated/openmm.app.simulation.Simulation.html) object from a System and an Integrator, but also provided a [Topology](https://docs.openmm.org/latest/api-python/generated/openmm.app.topology.Topology.html) that was loaded from our input files.  Since we have already set all of the parameters for our simulation in the System, OpenMM does not need a Topology to assign parameters from a ForceField, but some of the [reporter classes](https://docs.openmm.org/latest/api-python/app.html#reporting-output) still require a Topology for output, so we will demonstrate how to build one from scratch.  This process starts with creating an empty Topology:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "7e8b4abe-089e-42b4-942c-825c06ab4175",
   "metadata": {},
   "outputs": [],
   "source": [
    "topology = openmm.app.Topology()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "402a96ab-a3a7-43e0-a5df-24e47c01886b",
   "metadata": {},
   "source": [
    "The information in a Topology is structured hierarchically, with each Topology containing a list of [Chain](https://docs.openmm.org/latest/api-python/generated/openmm.app.topology.Chain.html) objects, each Chain a list of [Residue](https://docs.openmm.org/latest/api-python/generated/openmm.app.topology.Residue.html) objects, and each Residue a list of [Atom](https://docs.openmm.org/latest/api-python/generated/openmm.app.topology.Atom.html) objects.  For simulations of biopolymers, the elements of this hierarchy map naturally onto the standard meanings of their terms in biochemistry.  For other kinds of simulations like this one, there may not be a natural correspondence, and so there is some flexibility in how we construct the Topology.  Note that once a System is fully built, OpenMM only uses the Topology for reporting outputs like PDB files using OpenMM's standard reporters.  Thus, defining a Topology with the same number of atoms in a custom-built System, but with a nonsensical hierarchy or connectivity, will actually make no difference when running the simulation.\n",
    "\n",
    "For example, if we had a mixture of polyatomic molecules, we could create a Chain for each molecule, and either add all of the atoms in the molecule to one Residue in the Chain, or divide the atoms across several Residues if desired.  Alternatively, since there is no requirement that a Chain consist of a single connected molecule, we could assign one Residue per molecule and group molecules of each type into the a Chain for convenience.  We will take this latter approach here, and create Chain objects for each type of particle with [Topology.addChain()](https://docs.openmm.org/latest/api-python/generated/openmm.app.topology.Topology.html#openmm.app.topology.Topology.addChain):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "38f6f810-6c8a-4621-bf27-f4e128b2533a",
   "metadata": {},
   "outputs": [],
   "source": [
    "chain_A = topology.addChain()\n",
    "chain_B = topology.addChain()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9c8f30dc-e6f8-4e8d-bf6e-761edebac11b",
   "metadata": {},
   "source": [
    "We can add a Residue to an already created Chain with [Topology.addResidue()](https://docs.openmm.org/latest/api-python/generated/openmm.app.topology.Topology.html#openmm.app.topology.Topology.addResidue), providing a name to identify the Residue (which need not be unique).  Since this simulation uses single particles rather than polyatomic molecules, we add a single Atom to each Residue with [Topology.addAtom()](https://docs.openmm.org/latest/api-python/generated/openmm.app.topology.Topology.html#openmm.app.topology.Topology.addAtom).  In general, the name of each Atom should be unique within a Residue.  The Atoms should be added to the Topology in the same order that particles were added to the System."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "04826b84-f5da-4ee8-bb56-ce81090b9c97",
   "metadata": {},
   "outputs": [],
   "source": [
    "for i_A in range(N_A):\n",
    "    residue = topology.addResidue(\"A\", chain_A)\n",
    "    topology.addAtom(\"A\", None, residue)\n",
    "for i_B in range(N_B):\n",
    "    residue = topology.addResidue(\"B\", chain_B)\n",
    "    topology.addAtom(\"B\", None, residue)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d843f6dc-eee4-4219-90f7-0a61ae755bd7",
   "metadata": {},
   "source": [
    "The parameter to addAtom() set to `None` above specifies an optional chemical element for the Atom.  Since this is a model system, we do not set elements for the Atoms here, but OpenMM provides the [Element](https://docs.openmm.org/latest/api-python/generated/openmm.app.element.Element.html) class for use when appropriate.\n",
    "\n",
    "Now that we have a Topology, we can create a [Simulation](https://docs.openmm.org/latest/api-python/generated/openmm.app.simulation.Simulation.html) object, just as in the previous tutorials."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "d3e1587e-43e3-4ffc-8896-5e6d4567f22d",
   "metadata": {},
   "outputs": [],
   "source": [
    "simulation = openmm.app.Simulation(topology, system, integrator)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "286ceb62-d297-4d09-9c96-823ea7f325c2",
   "metadata": {},
   "source": [
    "When we set up a simulation from a PDB file, input coordinates were already available.  When building a System and a Topology from scratch, you will need to provide your own initial coordinates.  You can read them from any file format of your choice or generate them *via* any method of your choice, before passing them to [Context.setPositions()](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.Context.html#openmm.openmm.Context.setPositions).  In this example, we will generate a simple [rock salt (B1) lattice](https://www.atomic-scale-physics.de/lattice/struk/b1.html) for the initial positions of our particles:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "eb9cd22f-0729-471e-b9d2-7351057b0f8d",
   "metadata": {},
   "outputs": [],
   "source": [
    "grid_a, grid_b = [], []\n",
    "\n",
    "for i_x in range(10):\n",
    "    for i_y in range(10):\n",
    "        for i_z in range(10):\n",
    "            (grid_a, grid_b)[(i_x + i_y + i_z) % 2].append(openmm.Vec3(i_x / 10, i_y / 10, i_z / 10) * L_box)\n",
    "\n",
    "simulation.context.setPositions(grid_a + grid_b)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a4b22d54-e501-468a-84eb-6dd182ad5ea2",
   "metadata": {},
   "source": [
    "We can then minimize the energy of the initial configuration and set velocities:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "b640c875-d0e5-4c4c-b84a-b0b57e97613c",
   "metadata": {},
   "outputs": [],
   "source": [
    "simulation.minimizeEnergy()\n",
    "simulation.context.setVelocitiesToTemperature(temp)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7bcf2eb0-9609-46be-b076-38760485bd04",
   "metadata": {},
   "source": [
    "### Running Dynamics\n",
    "\n",
    "We are now ready to run simulation steps, just as we have done in the previous tutorials."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "2d95b07f-e7ec-4fae-8dee-54468c2074f0",
   "metadata": {},
   "outputs": [],
   "source": [
    "simulation.step(10000)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9661d86a-e12c-4470-afc3-2c73d52c373a",
   "metadata": {},
   "source": [
    "All of OpenMM's builtin reporters can be added to the Simulation as desired, as well as any custom reporters.  Here, we will instead calculate the radial distribution function (RDF) for each of the pairs of components in the mixture.  The details of the calculation are not germane to this tutorial, and the implementation here is not optimized.  As such, using an external library for such analysis is usually better, but the following illustrates a simple way to do this with NumPy alone."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "9cc2a385-6316-49f7-8b2b-b904adcb7b80",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define the edges of the bins on which to evaluate the RDFs.\n",
    "rdf_bins = np.linspace(0.0, 4.0, 401)\n",
    "\n",
    "# Make arrays in which to accumulate the RDFs.\n",
    "rdf_aa = np.zeros(rdf_bins.size - 1)\n",
    "rdf_bb = np.zeros(rdf_bins.size - 1)\n",
    "rdf_ab = np.zeros(rdf_bins.size - 1)\n",
    "\n",
    "# Track the number of accumulations we have done so far.\n",
    "rdf_count = 0\n",
    "\n",
    "def calculate_rdf(state):\n",
    "    global rdf_aa, rdf_bb, rdf_ab, rdf_count\n",
    "\n",
    "    # Extract the positions and box vectors from a State.\n",
    "    positions = state.getPositions(asNumpy=True) / length_scale\n",
    "    lengths = np.diag(state.getPeriodicBoxVectors() / length_scale)\n",
    "\n",
    "    # Apply the minimum image convention.  WARNING: This implementation ONLY works for orthorhombic periodic boxes!\n",
    "    # MonteCarloBarostat will not deform the periodic box, and it starts as a cube, so it works for this case.\n",
    "    dr_ij = positions[:, None] - positions[None, :]\n",
    "    dr_ij -= np.round(dr_ij / lengths) * lengths\n",
    "    r_ij = np.sqrt(np.sum(dr_ij * dr_ij, axis=-1))\n",
    "\n",
    "    # Get the distances between A-A, B-B, and A-B pairs.\n",
    "    r_aa = r_ij[:N_A, :N_A][np.triu_indices(N_A, 1)]\n",
    "    r_bb = r_ij[N_A:, N_A:][np.triu_indices(N_B, 1)]\n",
    "    r_ab = r_ij[:N_A, N_A:].flatten()\n",
    "\n",
    "    # Accumulate the RDFs.\n",
    "    rdf_aa += np.prod(lengths) * np.histogram(r_aa, bins=rdf_bins, weights=1.0 / (r_aa * r_aa))[0] / r_aa.size\n",
    "    rdf_bb += np.prod(lengths) * np.histogram(r_bb, bins=rdf_bins, weights=1.0 / (r_bb * r_bb))[0] / r_bb.size\n",
    "    rdf_ab += np.prod(lengths) * np.histogram(r_ab, bins=rdf_bins, weights=1.0 / (r_ab * r_ab))[0] / r_ab.size\n",
    "    rdf_count += 1"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "814b3559-5d0f-4698-be4c-8b1f36571190",
   "metadata": {},
   "source": [
    "We can then run some more simulation steps and measure the RDFs:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "24f4c15c-fd0f-469b-9c32-6ebabc6fd876",
   "metadata": {},
   "outputs": [],
   "source": [
    "for i in range(1000):\n",
    "    simulation.step(100)\n",
    "    calculate_rdf(simulation.context.getState(positions=True))\n",
    "\n",
    "# Average and normalize the RDFs so g(r) -> 1 as r -> infinity.\n",
    "rdf_scale = 1.0 / (4.0 * np.pi * rdf_count * (rdf_bins[1:] - rdf_bins[:-1]))\n",
    "rdf_aa *= rdf_scale\n",
    "rdf_bb *= rdf_scale\n",
    "rdf_ab *= rdf_scale"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "58bc695f-d742-4f49-9b80-5c5c5c705677",
   "metadata": {},
   "source": [
    "Plotting the results shows the peaks we might expect for a simple fluid.  Unsurprisingly, the peak of the A-B RDF for the first coordination shell falls halfway between those for the A-A and B-B RDFs, as might be expected since the mixing rule for $\\sigma_{ij}$ is the arithmetic mean:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "a534a45c-6f5c-4b94-8eaa-f45162994522",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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",
      "text/plain": [
       "<Figure size 400x300 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "figure = plt.figure(figsize=(4, 3), layout=\"constrained\")\n",
    "axes = figure.add_subplot(1, 1, 1)\n",
    "\n",
    "rdf_bins_center = (rdf_bins[:-1] + rdf_bins[1:]) / 2.0\n",
    "axes.plot(rdf_bins_center, rdf_aa, label=\"$g_{AA}$\")\n",
    "axes.plot(rdf_bins_center, rdf_bb, label=\"$g_{BB}$\")\n",
    "axes.plot(rdf_bins_center, rdf_ab, label=\"$g_{AB}$\")\n",
    "\n",
    "axes.set_xlim(rdf_bins[0], rdf_bins[-1])\n",
    "axes.set_ylim(0, None)\n",
    "axes.set_xlabel(\"$r$\")\n",
    "axes.set_ylabel(\"$g(r)$\")\n",
    "axes.legend()\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "38de19b2-137f-42c6-a42e-66fc3338df20",
   "metadata": {},
   "source": [
    "### Working Without a Simulation Object\n",
    "\n",
    "You may notice that the System and all of the Forces we used are members of the `openmm` package, *i.e.*, the library layer of OpenMM, while the Topology and Simulation are still part of the `openmm.app` package, that is, the application layer.  It is actually possible to use the library layer of OpenMM exclusively, never touching `openmm.app` at all.  To do this, once we have our System and Integrator, we can just [create a Context directly](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.Context.html#openmm.openmm.Context.__init__):\n",
    "```python\n",
    "context = openmm.Context(system, integrator)\n",
    "```\n",
    "We then access the Context as `context` rather than `simulation.context`.  In place of [Simulation.step()](https://docs.openmm.org/latest/api-python/generated/openmm.app.simulation.Simulation.html#openmm.app.simulation.Simulation.step), we could use [Integrator.step()](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.Integrator.html#openmm.openmm.Integrator.step), and in place of [Simulation.minimizeEnergy()](https://docs.openmm.org/latest/api-python/generated/openmm.app.simulation.Simulation.html#openmm.app.simulation.Simulation.minimizeEnergy), we could use OpenMM's [LocalEnergyMinimizer](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.LocalEnergyMinimizer.html).\n",
    "\n",
    "With this method, it is unnecessary to create a Topology for our System.  However, we lose the ability to use OpenMM's builtin reporters, and also lose some convenience features such as [Simulation.runForClockTime()](https://docs.openmm.org/latest/api-python/generated/openmm.app.simulation.Simulation.html#openmm.app.simulation.Simulation.runForClockTime).  Generally, using the Simulation class from the library layer is most convenient, but you could create and manage Context objects directly if, *e.g.*, you wanted to replace the OpenMM application layer's output reporting system with a completely custom framework for saving simulation results."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "104afd4f-38eb-4fd7-9743-62fee7ba8513",
   "metadata": {},
   "source": [
    "### The Completed Script\n",
    "\n",
    "In case you want to experiment with modifying the Python commands in this tutorial as a standalone Python script rather than as Jupyter notebook cells, they are given all together as follows:\n",
    "\n",
    "```python\n",
    "import openmm\n",
    "import openmm.app\n",
    "import openmm.unit\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "# Define dimensionless units.\n",
    "\n",
    "length_scale = openmm.unit.nanometer\n",
    "mass_scale = openmm.unit.dalton\n",
    "energy_scale = openmm.unit.kilojoule_per_mole\n",
    "time_scale = openmm.unit.picosecond\n",
    "\n",
    "press_scale = energy_scale / (length_scale ** 3 * openmm.unit.AVOGADRO_CONSTANT_NA)\n",
    "temp_scale = energy_scale / (openmm.unit.BOLTZMANN_CONSTANT_kB * openmm.unit.AVOGADRO_CONSTANT_NA)\n",
    "\n",
    "# Set simulation parameters.\n",
    "\n",
    "N_A = 500\n",
    "N_B = 500\n",
    "\n",
    "rho = 0.6 / length_scale ** 3\n",
    "\n",
    "m_A = 1.0 * mass_scale\n",
    "m_B = 1.1 * mass_scale\n",
    "\n",
    "r_cut = 3.0 * length_scale\n",
    "\n",
    "sigma_A = 1.0 * length_scale\n",
    "sigma_B = 1.2 * length_scale\n",
    "\n",
    "epsilon_A = 1.0 * energy_scale\n",
    "epsilon_B = 1.3 * energy_scale\n",
    "\n",
    "press = 2.0 * press_scale\n",
    "temp = 1.5 * temp_scale\n",
    "friction = 1.0 / time_scale\n",
    "step = 0.005 * time_scale\n",
    "\n",
    "# Create the System.\n",
    "\n",
    "system = openmm.System()\n",
    "\n",
    "L_box = ((N_A + N_B) / rho) ** (1 / 3)\n",
    "system.setDefaultPeriodicBoxVectors(openmm.Vec3(L_box, 0, 0), openmm.Vec3(0, L_box, 0), openmm.Vec3(0, 0, L_box))\n",
    "\n",
    "for i_A in range(N_A):\n",
    "    system.addParticle(m_A)\n",
    "for i_B in range(N_B):\n",
    "    system.addParticle(m_B)\n",
    "\n",
    "lj = openmm.NonbondedForce()\n",
    "lj.setNonbondedMethod(openmm.NonbondedForce.CutoffPeriodic)\n",
    "lj.setCutoffDistance(r_cut)\n",
    "\n",
    "for i_A in range(N_A):\n",
    "    lj.addParticle(0.0, sigma_A, epsilon_A)\n",
    "for i_B in range(N_B):\n",
    "    lj.addParticle(0.0, sigma_B, epsilon_B)\n",
    "\n",
    "system.addForce(lj)\n",
    "\n",
    "system.addForce(openmm.MonteCarloBarostat(press, temp))\n",
    "\n",
    "# Create the Integrator.\n",
    "\n",
    "integrator = openmm.LangevinMiddleIntegrator(temp, friction, step)\n",
    "\n",
    "# Create the Topology.\n",
    "\n",
    "topology = openmm.app.Topology()\n",
    "\n",
    "chain_A = topology.addChain()\n",
    "chain_B = topology.addChain()\n",
    "\n",
    "for i_A in range(N_A):\n",
    "    residue = topology.addResidue(\"A\", chain_A)\n",
    "    topology.addAtom(\"A\", None, residue)\n",
    "for i_B in range(N_B):\n",
    "    residue = topology.addResidue(\"B\", chain_B)\n",
    "    topology.addAtom(\"B\", None, residue)\n",
    "\n",
    "# Create the Simulation, and prepare initial positions and velocities.\n",
    "\n",
    "simulation = openmm.app.Simulation(topology, system, integrator)\n",
    "\n",
    "grid_a, grid_b = [], []\n",
    "\n",
    "for i_x in range(10):\n",
    "    for i_y in range(10):\n",
    "        for i_z in range(10):\n",
    "            (grid_a, grid_b)[(i_x + i_y + i_z) % 2].append(openmm.Vec3(i_x / 10, i_y / 10, i_z / 10) * L_box)\n",
    "\n",
    "simulation.context.setPositions(grid_a + grid_b)\n",
    "simulation.minimizeEnergy()\n",
    "simulation.context.setVelocitiesToTemperature(temp)\n",
    "\n",
    "# Run dynamics steps for equilibration.\n",
    "\n",
    "simulation.step(10000)\n",
    "\n",
    "# Set up RDF reporting as an example.\n",
    "\n",
    "# Define the edges of the bins on which to evaluate the RDFs.\n",
    "rdf_bins = np.linspace(0.0, 4.0, 401)\n",
    "\n",
    "# Make arrays in which to accumulate the RDFs.\n",
    "rdf_aa = np.zeros(rdf_bins.size - 1)\n",
    "rdf_bb = np.zeros(rdf_bins.size - 1)\n",
    "rdf_ab = np.zeros(rdf_bins.size - 1)\n",
    "\n",
    "# Track the number of accumulations we have done so far.\n",
    "rdf_count = 0\n",
    "\n",
    "def calculate_rdf(state):\n",
    "    global rdf_aa, rdf_bb, rdf_ab, rdf_count\n",
    "\n",
    "    # Extract the positions and box vectors from a State.\n",
    "    positions = state.getPositions(asNumpy=True) / length_scale\n",
    "    lengths = np.diag(state.getPeriodicBoxVectors() / length_scale)\n",
    "\n",
    "    # Apply the minimum image convention.  WARNING: This implementation ONLY works for orthorhombic periodic boxes!\n",
    "    # MonteCarloBarostat will not deform the periodic box, and it starts as a cube, so it works for this case.\n",
    "    dr_ij = positions[:, None] - positions[None, :]\n",
    "    dr_ij -= np.round(dr_ij / lengths) * lengths\n",
    "    r_ij = np.sqrt(np.sum(dr_ij * dr_ij, axis=-1))\n",
    "\n",
    "    # Get the distances between A-A, B-B, and A-B pairs.\n",
    "    r_aa = r_ij[:N_A, :N_A][np.triu_indices(N_A, 1)]\n",
    "    r_bb = r_ij[N_A:, N_A:][np.triu_indices(N_B, 1)]\n",
    "    r_ab = r_ij[:N_A, N_A:].flatten()\n",
    "\n",
    "    # Accumulate the RDFs.\n",
    "    rdf_aa += np.prod(lengths) * np.histogram(r_aa, bins=rdf_bins, weights=1.0 / (r_aa * r_aa))[0] / r_aa.size\n",
    "    rdf_bb += np.prod(lengths) * np.histogram(r_bb, bins=rdf_bins, weights=1.0 / (r_bb * r_bb))[0] / r_bb.size\n",
    "    rdf_ab += np.prod(lengths) * np.histogram(r_ab, bins=rdf_bins, weights=1.0 / (r_ab * r_ab))[0] / r_ab.size\n",
    "    rdf_count += 1\n",
    "\n",
    "# Run dynamics steps for production.\n",
    "\n",
    "for i in range(1000):\n",
    "    simulation.step(100)\n",
    "    calculate_rdf(simulation.context.getState(positions=True))\n",
    "\n",
    "# Average and normalize the RDFs.\n",
    "\n",
    "rdf_scale = 1.0 / (4.0 * np.pi * rdf_count * (rdf_bins[1:] - rdf_bins[:-1]))\n",
    "rdf_aa *= rdf_scale\n",
    "rdf_bb *= rdf_scale\n",
    "rdf_ab *= rdf_scale\n",
    "\n",
    "# Plot the results.\n",
    "\n",
    "figure = plt.figure(figsize=(4, 3), layout=\"constrained\")\n",
    "axes = figure.add_subplot(1, 1, 1)\n",
    "\n",
    "rdf_bins_center = (rdf_bins[:-1] + rdf_bins[1:]) / 2.0\n",
    "axes.plot(rdf_bins_center, rdf_aa, label=\"$g_{AA}$\")\n",
    "axes.plot(rdf_bins_center, rdf_bb, label=\"$g_{BB}$\")\n",
    "axes.plot(rdf_bins_center, rdf_ab, label=\"$g_{AB}$\")\n",
    "\n",
    "axes.set_xlim(rdf_bins[0], rdf_bins[-1])\n",
    "axes.set_ylim(0, None)\n",
    "axes.set_xlabel(\"$r$\")\n",
    "axes.set_ylabel(\"$g(r)$\")\n",
    "axes.legend()\n",
    "\n",
    "plt.show()\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1c77c4e1-027c-404f-9cdc-b00e6914655b",
   "metadata": {},
   "source": [
    "## Summary and Further Reading\n",
    "\n",
    "After following this tutorial, you should be able to:\n",
    "* Build an OpenMM System from scratch for a Lennard-Jones fluid mixture\n",
    "* Build a Topology from scratch and use it with a System to create a Simulation\n",
    "* Work with dimensionless units in OpenMM\n",
    "\n",
    "This tutorial only covered the basics of setting up a System from scratch in OpenMM.  OpenMM's library layer comes with a [large number of Forces](https://docs.openmm.org/latest/api-python/library.html#forces) implementing all kinds of bonded and non-bonded interactions.  OpenMM provides standard interactions found in many classical molecular mechanics force fields, such as [HarmonicBondForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.HarmonicBondForce.html) and [PeriodicTorsionForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.PeriodicTorsionForce.html).  However, it also provides a large number of *custom forces*, which allow you to define interactions from arbitrary expressions.  This flexibility enables you to use many kinds of potential functions in OpenMM without needing to write any additional C++ or even Python code.  The theory section of the user guide details most of the [standard](https://docs.openmm.org/latest/userguide/theory/02_standard_forces.html) and [custom](https://docs.openmm.org/latest/userguide/theory/03_custom_forces.html) forces listed in the API documentation.\n",
    "\n",
    "These introductory tutorials have now covered the basics of using OpenMM to load and parameterize existing molecular structures, read input files for other molecular dynamics engines, and build custom molecular systems from the ground up.  At this point, you should be equipped to understand the details of the [more advanced tutorials](../../tutorials.rst#beyond-the-basics), which describe how to set up specific kinds of simulations or implement specific methods with OpenMM.  Unlike this introductory series, designed to be followed in order, the other tutorials are mostly standalone units: when this is not the case, links will be provided to any prerequisites.  You may also want to consult the [OpenMM Cookbook](../../cookbook.rst) for shorter examples of how to accomplish particular tasks in OpenMM.\n",
    "\n",
    "Although it does not introduce significant new parts of the OpenMM API, we strongly recommend that you continue to the final introductory tutorial on [choosing simulation parameters](simulation_parameters.ipynb).  Up to this point, these tutorials have used default values from OpenMM Setup for, *e.g.*, integration timesteps and tolerances, or have chosen values that should be appropriate for the systems in question.  The next tutorial describes some of these parameters and when their default values might not be suitable, and discusses how to choose values for your own simulations."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ccabe72f-8028-42f6-8ff5-6ea287f03f7a",
   "metadata": {},
   "source": [
    "## Links\n",
    "\n",
    "* Relevant sections of the [User Guide](https://docs.openmm.org/latest/api-python/):\n",
    "  * [Units and dimensional analysis](https://docs.openmm.org/latest/userguide/library/05_languages_not_cpp.html#units-and-dimensional-analysis) in the Python API\n",
    "  * [Units](https://docs.openmm.org/latest/userguide/theory/01_introduction.html#units) and [physical constants](https://docs.openmm.org/latest/userguide/theory/01_introduction.html#physical-constants) used by default in OpenMM\n",
    "  * Theory behind [Standard Forces](https://docs.openmm.org/latest/userguide/theory/02_standard_forces.html)\n",
    "  * Theory behind [Custom Forces](https://docs.openmm.org/latest/userguide/theory/03_custom_forces.html)\n",
    "* [Python API documentation](https://docs.openmm.org/latest/api-python/) pages for:\n",
    "  * Common standard forces (not exhaustive):\n",
    "    * [HarmonicBondForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.HarmonicBondForce.html)\n",
    "    * [HarmonicAngleForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.HarmonicAngleForce.html)\n",
    "    * [PeriodicTorsionForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.PeriodicTorsionForce.html)\n",
    "    * [CMAPTorsionForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.CMAPTorsionForce.html)\n",
    "    * [NonbondedForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html)\n",
    "  * Common custom forces (not exhaustive):\n",
    "    * [CustomBondForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.CustomBondForce.html)\n",
    "    * [CustomAngleForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.CustomAngleForce.html)\n",
    "    * [CustomTorsionForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.CustomTorsionForce.html)\n",
    "    * [CustomExternalForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.CustomExternalForce.html)\n",
    "    * [CustomCompoundBondForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.CustomCompoundBondForce.html)\n",
    "    * [CustomNonbondedForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.CustomNonbondedForce.html)\n",
    "    * [CustomManyParticleForce](https://docs.openmm.org/latest/api-python/generated/openmm.openmm.CustomManyParticleForce.html)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.7"
  },
  "required_files": []
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
