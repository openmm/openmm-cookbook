<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Run a REST simulation &#8212; OpenMM Cookbook &amp; Tutorials dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="../../_static/nbsphinx-code-cells.css?v=2aa19091" />
    <link rel="stylesheet" type="text/css" href="../../_static/notebooks.css?v=9b8a9a20" />
    <script src="../../_static/documentation_options.js?v=3ce10a4d"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Umbrella Sampling" href="umbrella_sampling.html" />
    <link rel="prev" title="Histone methyltransferase simulation with multisite Zn2+ structural ions" href="Histone_methyltransferase_simulation_with_multisite_Zn2_structural_ions.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="nbsphinx-prolog">
    <a href="Running_a_REST_simulation.ipynb">Download Notebook</a>
    <a href="https://github.com/openmm/openmm-cookbook/blob/main/notebooks/tutorials/Running_a_REST_simulation.ipynb">View in GitHub</a>
    <a href="https://colab.research.google.com/github/openmm/openmm-cookbook/blob/gh-pages/dev/colab/notebooks/tutorials/Running_a_REST_simulation.ipynb">Open in Google Colab</a>
</div><span class="target" id="index-0"></span><section id="Run-a-REST-simulation">
<h1>Run a REST simulation<a class="headerlink" href="#Run-a-REST-simulation" title="Link to this heading">¶</a></h1>
<p>Replica exchange solute tempering (REST) is an enhanced sampling approach that aims to improve sampling for a user-defined subset of atoms (i.e., REST atoms) by increasing its effective temperature.</p>
<p>REST involves running replica exchange to sample a set of thermodynamic states, where one state contains the unmodified Hamiltonian and all other states involve modified Hamiltonians where the REST atom interactions are scaled to increased temperatures (Wang et al. 2011, DOI: 10.1021/jp204407d, available at: <a class="reference external" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3172817/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3172817/</a>).</p>
<p>In this tutorial, we show how to 1) build a REST-capable OpenMM system and then 2) run REST (using OpenMMTools (<a class="reference external" href="https://openmmtools.readthedocs.io">https://openmmtools.readthedocs.io</a>) objects).</p>
<p>Overview of the tutorial:</p>
<p>Build a REST-capable system</p>
<ul class="simple">
<li><p>We first build a “vanilla” OpenMM <code class="docutils literal notranslate"><span class="pre">System</span></code>, which represents the unmodified Hamiltonian from which we will construct the modified REST Hamiltonian (i.e., the REST system).</p></li>
<li><p>We then define the REST atoms, i.e., the atoms whose interactions will be heated up.</p></li>
<li><p>We begin creating the REST system by initializing an empty OpenMM <code class="docutils literal notranslate"><span class="pre">System</span></code> and copying the particles, barostat, box vectors, and constraints from the vanilla system.</p></li>
<li><p>We then create custom forces for each valence force in the REST system: <code class="docutils literal notranslate"><span class="pre">CustomBondForce</span></code>, <code class="docutils literal notranslate"><span class="pre">CustomAngleForce</span></code>, <code class="docutils literal notranslate"><span class="pre">CustomTorsionForce</span></code>, where each force has a custom expression that allow the energy to be scaled according to REST. Each custom expression utilizes a global parameter to control the REST scale factor and per-bond (or per-angle or per-torsion) parameters to keep track of parameters needed to compute the energy for each bond (or angle or torsion).</p></li>
<li><p>For the REST system’s nonbonded force, we create a <code class="docutils literal notranslate"><span class="pre">NonbondedForce</span></code> and use offsets to scale the energies for interactions involving REST atoms. We use the <code class="docutils literal notranslate"><span class="pre">NonbondedForce</span></code> (and not custom forces) for simplicity. If we used custom forces, we would need to use a <code class="docutils literal notranslate"><span class="pre">CustomNonbondedForce</span></code> for nonbonded interactions and a <code class="docutils literal notranslate"><span class="pre">CustomBondForce</span></code> for nonbonded exceptions, and these forces can be tricky to work with.</p></li>
<li><p>Finally, we copy the bonds, angles, torsions, particles, and nonbonded exceptions from each force in the vanilla system to each new force in the REST system.</p></li>
</ul>
<p>Run REST</p>
<ul class="simple">
<li><p>We define a class called RESTState that creates a “state” (aka version of the REST system) with a particular set of global parameters.</p></li>
<li><p>We choose the temperatures we’d like use for REST scaling and then create thermodynamic states corresponding to each temperature using the previously defined RESTState class. For each thermodynamic state, we minimize the positions with respect to the modified Hamiltonian.</p></li>
<li><p>Finally, we create a replica exchange sampler that samples each of the thermodynamic states and use the sampler to run the replica exchange simulation.</p></li>
</ul>
<p>Note that this tutorial is inspired by the <code class="docutils literal notranslate"><span class="pre">RESTCapableHybridTopologyFactory</span></code> in Perses (<a class="reference external" href="https://github.com/choderalab/perses">https://github.com/choderalab/perses</a>), which can be used to run relative alchemical free energy calculations.</p>
<section id="01---Construct-a-vanilla-OpenMM-system">
<h2>01 - Construct a vanilla OpenMM system<a class="headerlink" href="#01---Construct-a-vanilla-OpenMM-system" title="Link to this heading">¶</a></h2>
<p>We first load a PDB file consisting of villin in water and build a <code class="docutils literal notranslate"><span class="pre">System</span></code> from it, which we refer to as the “vanilla system”. The villin PDB file is present in the current directory (<code class="docutils literal notranslate"><span class="pre">openmm-cookbook/notebooks/cookbook/</span></code>), but can be also be downloaded here: <a class="reference external" href="https://raw.githubusercontent.com/openmm/openmm-cookbook/main/notebooks/cookbook/villin.pdb">https://raw.githubusercontent.com/openmm/openmm-cookbook/main/notebooks/cookbook/villin.pdb</a></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">openmm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openmm</span><span class="w"> </span><span class="kn">import</span> <span class="n">app</span><span class="p">,</span> <span class="n">unit</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pdb</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">PDBFile</span><span class="p">(</span><span class="s1">&#39;villin.pdb&#39;</span><span class="p">)</span>
<span class="n">forcefield</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">ForceField</span><span class="p">(</span><span class="s1">&#39;amber14-all.xml&#39;</span><span class="p">,</span> <span class="s1">&#39;amber14/tip3pfb.xml&#39;</span><span class="p">)</span>
<span class="n">system</span> <span class="o">=</span> <span class="n">forcefield</span><span class="o">.</span><span class="n">createSystem</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">topology</span><span class="p">,</span>
                                 <span class="n">nonbondedMethod</span><span class="o">=</span><span class="n">app</span><span class="o">.</span><span class="n">PME</span><span class="p">,</span>
                                 <span class="n">nonbondedCutoff</span><span class="o">=</span><span class="mi">1</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">nanometer</span><span class="p">,</span>
                                 <span class="n">constraints</span><span class="o">=</span><span class="n">app</span><span class="o">.</span><span class="n">HBonds</span><span class="p">,</span>
                                 <span class="n">removeCMMotion</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">hydrogenMass</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">amu</span><span class="p">)</span>
<span class="n">barostat</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">MonteCarloBarostat</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">atmosphere</span><span class="p">,</span> <span class="mi">300</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">kelvin</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">system</span><span class="o">.</span><span class="n">addForce</span><span class="p">(</span><span class="n">barostat</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
4
</pre></div></div>
</div>
<p>We check the forces in the vanilla system to make sure they’re as expected.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">system</span><span class="o">.</span><span class="n">getForces</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[&lt;openmm.openmm.HarmonicBondForce; proxy of &lt;Swig Object of type &#39;OpenMM::HarmonicBondForce *&#39; at 0x11fae7450&gt; &gt;,
 &lt;openmm.openmm.NonbondedForce; proxy of &lt;Swig Object of type &#39;OpenMM::NonbondedForce *&#39; at 0x11fae7e70&gt; &gt;,
 &lt;openmm.openmm.PeriodicTorsionForce; proxy of &lt;Swig Object of type &#39;OpenMM::PeriodicTorsionForce *&#39; at 0x11fae7f60&gt; &gt;,
 &lt;openmm.openmm.HarmonicAngleForce; proxy of &lt;Swig Object of type &#39;OpenMM::HarmonicAngleForce *&#39; at 0x11fae7300&gt; &gt;,
 &lt;openmm.openmm.MonteCarloBarostat; proxy of &lt;Swig Object of type &#39;OpenMM::MonteCarloBarostat *&#39; at 0x11fae72d0&gt; &gt;]
</pre></div></div>
</div>
</section>
<section id="02---Construct-a-REST-capable-OpenMM-system">
<h2>02 - Construct a REST-capable OpenMM system<a class="headerlink" href="#02---Construct-a-REST-capable-OpenMM-system" title="Link to this heading">¶</a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
</pre></div>
</div>
</div>
<p>We now choose the REST atoms to be all atoms in one residue (residue index 3) of villin.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">residues</span><span class="p">())[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">rest_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">atoms</span><span class="p">()]</span>
</pre></div>
</div>
</div>
<p>There are 15 REST atoms.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">rest_atoms</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
15
</pre></div></div>
</div>
<p>We create a new <code class="docutils literal notranslate"><span class="pre">System</span></code> (which we refer to as the “REST system”) and copy over the particles, barostat, box vectors, and constraints from the vanilla system.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create REST system</span>
<span class="n">rest_system</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">System</span><span class="p">()</span>

<span class="c1"># Create dict of vanilla system forces (for easy retrieval of force objects later)</span>
<span class="n">system_forces</span> <span class="o">=</span> <span class="p">{</span><span class="nb">type</span><span class="p">(</span><span class="n">force</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="p">:</span> <span class="n">force</span> <span class="k">for</span> <span class="n">force</span> <span class="ow">in</span> <span class="n">system</span><span class="o">.</span><span class="n">getForces</span><span class="p">()}</span>

<span class="c1"># Add particles</span>
<span class="k">for</span> <span class="n">particle_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">getNumParticles</span><span class="p">()):</span>
    <span class="n">particle_mass</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">getParticleMass</span><span class="p">(</span><span class="n">particle_idx</span><span class="p">)</span>
    <span class="n">rest_system</span><span class="o">.</span><span class="n">addParticle</span><span class="p">(</span><span class="n">particle_mass</span><span class="p">)</span>

<span class="c1"># Copy barostat</span>
<span class="k">if</span> <span class="s2">&quot;MonteCarloBarostat&quot;</span> <span class="ow">in</span> <span class="n">system_forces</span><span class="p">:</span>
    <span class="n">barostat</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">system_forces</span><span class="p">[</span><span class="s2">&quot;MonteCarloBarostat&quot;</span><span class="p">])</span>
    <span class="n">rest_system</span><span class="o">.</span><span class="n">addForce</span><span class="p">(</span><span class="n">barostat</span><span class="p">)</span>

<span class="c1"># Copy box vectors</span>
<span class="n">box_vectors</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">getDefaultPeriodicBoxVectors</span><span class="p">()</span>
<span class="n">rest_system</span><span class="o">.</span><span class="n">setDefaultPeriodicBoxVectors</span><span class="p">(</span><span class="o">*</span><span class="n">box_vectors</span><span class="p">)</span>

<span class="c1"># Copy constraints</span>
<span class="k">for</span> <span class="n">constraint_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">getNumConstraints</span><span class="p">()):</span>
    <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">getConstraintParameters</span><span class="p">(</span><span class="n">constraint_idx</span><span class="p">)</span>
    <span class="n">rest_system</span><span class="o">.</span><span class="n">addConstraint</span><span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>We create the REST system’s bond force as a <code class="docutils literal notranslate"><span class="pre">CustomBondForce</span></code> which uses a custom energy expression that allows for REST scaling. We add a global parameter (<code class="docutils literal notranslate"><span class="pre">lambda_rest_bonds</span></code>) to act as the REST scale factor for bonds, i.e., to control the extent to which the bonds involving REST atoms are scaled.</p>
<p>We add per-bond parameters that are booleans indicating whether each bond is:</p>
<ul class="simple">
<li><p>REST (if all atoms are REST atoms, <code class="docutils literal notranslate"><span class="pre">is_rest</span></code> is 1, otherwise 0)</p></li>
<li><p>inter (if at least one, but not all atoms are REST atoms, <code class="docutils literal notranslate"><span class="pre">is_inter</span></code> is 1, otherwise 0), or</p></li>
<li><p>non-REST (if no atoms are REST atoms, <code class="docutils literal notranslate"><span class="pre">is_nonrest</span></code> is 1, otherwise 0).</p></li>
</ul>
<p>We also add per-bond parameters that keep track of the length and spring constant for each bond.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the custom expression</span>
<span class="n">bond_expression</span> <span class="o">=</span> <span class="s2">&quot;rest_scale * (K / 2) * (r - length)^2;&quot;</span>
<span class="n">bond_expression</span> <span class="o">+=</span> <span class="s2">&quot;rest_scale = is_rest * lambda_rest_bonds * lambda_rest_bonds &quot;</span> \
                   <span class="s2">&quot;+ is_inter * lambda_rest_bonds &quot;</span> \
                   <span class="s2">&quot;+ is_nonrest;&quot;</span>

<span class="c1"># Create custom force</span>
<span class="n">rest_bond_force</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">CustomBondForce</span><span class="p">(</span><span class="n">bond_expression</span><span class="p">)</span>
<span class="n">rest_system</span><span class="o">.</span><span class="n">addForce</span><span class="p">(</span><span class="n">rest_bond_force</span><span class="p">)</span>

<span class="c1"># Add global parameters</span>
<span class="n">rest_bond_force</span><span class="o">.</span><span class="n">addGlobalParameter</span><span class="p">(</span><span class="s2">&quot;lambda_rest_bonds&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># Add per-bond parameters for rest scaling</span>
<span class="n">rest_bond_force</span><span class="o">.</span><span class="n">addPerBondParameter</span><span class="p">(</span><span class="s2">&quot;is_rest&quot;</span><span class="p">)</span>
<span class="n">rest_bond_force</span><span class="o">.</span><span class="n">addPerBondParameter</span><span class="p">(</span><span class="s2">&quot;is_inter&quot;</span><span class="p">)</span>
<span class="n">rest_bond_force</span><span class="o">.</span><span class="n">addPerBondParameter</span><span class="p">(</span><span class="s2">&quot;is_nonrest&quot;</span><span class="p">)</span>

<span class="c1"># Add per-bond parameters for defining bond energy</span>
<span class="n">rest_bond_force</span><span class="o">.</span><span class="n">addPerBondParameter</span><span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">)</span>  <span class="c1"># equilibrium bond length</span>
<span class="n">rest_bond_force</span><span class="o">.</span><span class="n">addPerBondParameter</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>  <span class="c1"># force constant</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
4
</pre></div></div>
</div>
<p>We next want to add bonds to the REST system’s bond force. To do so, we need to determine whether each bond should be considered REST, inter, or non-REST, so that we can set each of the following per-bond parameters: <code class="docutils literal notranslate"><span class="pre">is_rest</span></code>, <code class="docutils literal notranslate"><span class="pre">is_inter</span></code>, <code class="docutils literal notranslate"><span class="pre">is_nonrest</span></code>. We define a function <code class="docutils literal notranslate"><span class="pre">get_rest_identifier</span></code> to do this.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_rest_identifier</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">rest_atoms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a given atom or set of atoms, get the rest_id which is a list of binary ints that defines which</span>
<span class="sd">    (mutually exclusive) set the atom(s) belong to.</span>

<span class="sd">    If there is a single atom, the sets are: is_rest, is_nonrest</span>
<span class="sd">    If there is a set of atoms, the sets are: is_rest, is_inter, is_nonrest</span>

<span class="sd">    Example: if there is a single atom that is in the nonrest set, the rest_id is [0, 1]</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    atoms : set or int</span>
<span class="sd">        a set of hybrid atom indices or single atom</span>
<span class="sd">    rest_atoms : set or list</span>
<span class="sd">        a list (or list-like) of atoms whose interactions will be scaled by REST</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rest_id : list</span>
<span class="sd">        list of binaries indicating which set the atom(s) belong to</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">rest_id</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># Set the default rest_id to non-REST</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">rest_atoms</span><span class="p">:</span>
            <span class="n">rest_id</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rest_id</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
        <span class="n">rest_id</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># Set the default rest_id to non-REST</span>
        <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">rest_atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">():</span> <span class="c1"># At least one of the atoms is REST</span>
            <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">rest_atoms</span><span class="p">):</span> <span class="c1"># All atoms are REST</span>
                <span class="n">rest_id</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># At least one (but not all) of the atoms is are REST</span>
                <span class="n">rest_id</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rest_id</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;atoms is of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="si">}</span><span class="s2">, but only `int` and `set` are allowable&quot;</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<p>Now we can add the bonds to the REST system’s bond force. We copy the periodic boundary conditions and bonds from the vanilla system’s bond force to the REST system’s bond force. Each bond is defined by the indices of the two atoms that form the bond (<code class="docutils literal notranslate"><span class="pre">p1</span></code>, <code class="docutils literal notranslate"><span class="pre">p1</span></code>), the bond length (<code class="docutils literal notranslate"><span class="pre">r0</span></code>), and the force constant (<code class="docutils literal notranslate"><span class="pre">k</span></code>). Each bond also has a <code class="docutils literal notranslate"><span class="pre">rest_id</span></code> (determined using <code class="docutils literal notranslate"><span class="pre">get_rest_identifier()</span></code>, defined above), which indicates whether each bond should be considered REST, inter, or
non-REST.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get vanilla system bond force</span>
<span class="n">bond_force</span> <span class="o">=</span> <span class="n">system_forces</span><span class="p">[</span><span class="s1">&#39;HarmonicBondForce&#39;</span><span class="p">]</span>

<span class="c1"># Set periodicity</span>
<span class="k">if</span> <span class="n">bond_force</span><span class="o">.</span><span class="n">usesPeriodicBoundaryConditions</span><span class="p">():</span>
    <span class="n">rest_bond_force</span><span class="o">.</span><span class="n">setUsesPeriodicBoundaryConditions</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Add bonds to rest_system</span>
<span class="k">for</span> <span class="n">term_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bond_force</span><span class="o">.</span><span class="n">getNumBonds</span><span class="p">()):</span>
    <span class="c1"># Get the bond parameters and rest id</span>
    <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">bond_force</span><span class="o">.</span><span class="n">getBondParameters</span><span class="p">(</span><span class="n">term_idx</span><span class="p">)</span>
    <span class="n">idx_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">])</span>
    <span class="n">rest_id</span> <span class="o">=</span> <span class="n">get_rest_identifier</span><span class="p">(</span><span class="n">idx_set</span><span class="p">,</span> <span class="n">rest_atoms</span><span class="p">)</span>

    <span class="c1"># Add the bond</span>
    <span class="n">bond_term</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">rest_id</span> <span class="o">+</span> <span class="p">[</span><span class="n">r0</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span>
    <span class="n">rest_bond_force</span><span class="o">.</span><span class="n">addBond</span><span class="p">(</span><span class="o">*</span><span class="n">bond_term</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<p>We then repeat the same process to 1) construct the REST system’s angle force (i.e., a <code class="docutils literal notranslate"><span class="pre">CustomAngleForce</span></code>) and 2) copy the angles from the vanilla system’s angle force to the REST system’s angle force.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the custom expression</span>
<span class="n">angle_expression</span> <span class="o">=</span> <span class="s2">&quot;rest_scale * (K / 2) * (theta - theta0)^2;&quot;</span>
<span class="n">angle_expression</span> <span class="o">+=</span> <span class="s2">&quot;rest_scale = is_rest * lambda_rest_angles * lambda_rest_angles &quot;</span> \
                    <span class="s2">&quot;+ is_inter * lambda_rest_angles &quot;</span> \
                    <span class="s2">&quot;+ is_nonrest;&quot;</span>

<span class="c1"># Create custom force</span>
<span class="n">rest_angle_force</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">CustomAngleForce</span><span class="p">(</span><span class="n">angle_expression</span><span class="p">)</span>
<span class="n">rest_system</span><span class="o">.</span><span class="n">addForce</span><span class="p">(</span><span class="n">rest_angle_force</span><span class="p">)</span>

<span class="c1"># Add global parameters</span>
<span class="n">rest_angle_force</span><span class="o">.</span><span class="n">addGlobalParameter</span><span class="p">(</span><span class="s2">&quot;lambda_rest_angles&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># Add per-angle parameters for rest scaling</span>
<span class="n">rest_angle_force</span><span class="o">.</span><span class="n">addPerAngleParameter</span><span class="p">(</span><span class="s2">&quot;is_rest&quot;</span><span class="p">)</span>
<span class="n">rest_angle_force</span><span class="o">.</span><span class="n">addPerAngleParameter</span><span class="p">(</span><span class="s2">&quot;is_inter&quot;</span><span class="p">)</span>
<span class="n">rest_angle_force</span><span class="o">.</span><span class="n">addPerAngleParameter</span><span class="p">(</span><span class="s2">&quot;is_nonrest&quot;</span><span class="p">)</span>

<span class="c1"># Add per-angle parameters for defining angle energy</span>
<span class="n">rest_angle_force</span><span class="o">.</span><span class="n">addPerAngleParameter</span><span class="p">(</span><span class="s1">&#39;theta0&#39;</span><span class="p">)</span>  <span class="c1"># equilibrium angle</span>
<span class="n">rest_angle_force</span><span class="o">.</span><span class="n">addPerAngleParameter</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>  <span class="c1"># force constant</span>

<span class="c1"># Get vanilla system angle force</span>
<span class="n">angle_force</span> <span class="o">=</span> <span class="n">system_forces</span><span class="p">[</span><span class="s1">&#39;HarmonicAngleForce&#39;</span><span class="p">]</span>

<span class="c1"># Set periodicity</span>
<span class="k">if</span> <span class="n">angle_force</span><span class="o">.</span><span class="n">usesPeriodicBoundaryConditions</span><span class="p">():</span>
    <span class="n">rest_angle_force</span><span class="o">.</span><span class="n">setUsesPeriodicBoundaryConditions</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Add angles to rest_system</span>
<span class="k">for</span> <span class="n">term_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">angle_force</span><span class="o">.</span><span class="n">getNumAngles</span><span class="p">()):</span>
    <span class="c1"># Get the angle parameters and rest id</span>
    <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">angle_force</span><span class="o">.</span><span class="n">getAngleParameters</span><span class="p">(</span><span class="n">term_idx</span><span class="p">)</span>
    <span class="n">idx_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">])</span>
    <span class="n">rest_id</span> <span class="o">=</span> <span class="n">get_rest_identifier</span><span class="p">(</span><span class="n">idx_set</span><span class="p">,</span> <span class="n">rest_atoms</span><span class="p">)</span>

    <span class="c1"># Add the angle</span>
    <span class="n">angle_term</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">rest_id</span> <span class="o">+</span> <span class="p">[</span><span class="n">theta0</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span>
    <span class="n">rest_angle_force</span><span class="o">.</span><span class="n">addAngle</span><span class="p">(</span><span class="o">*</span><span class="n">angle_term</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<p>We next repeat the same process to 1) construct the REST system’s torsion force (i.e., a <code class="docutils literal notranslate"><span class="pre">PeriodicTorsionForce</span></code>) and 2) copy the torsions from the vanilla system’s torsion force to the REST system’s torsion force.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the custom expression</span>
<span class="n">torsion_expression</span> <span class="o">=</span> <span class="s2">&quot;rest_scale * U;&quot;</span>
<span class="n">torsion_expression</span> <span class="o">+=</span> <span class="s2">&quot;rest_scale = is_rest * lambda_rest_torsions * lambda_rest_torsions &quot;</span> \
                      <span class="s2">&quot;+ is_inter * lambda_rest_torsions &quot;</span> \
                      <span class="s2">&quot;+ is_nonrest;&quot;</span>
<span class="n">torsion_expression</span> <span class="o">+=</span> <span class="s2">&quot;U = (K * (1 + cos(periodicity * theta - phase)));&quot;</span>

<span class="c1"># Create custom force</span>
<span class="n">rest_torsion_force</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">CustomTorsionForce</span><span class="p">(</span><span class="n">torsion_expression</span><span class="p">)</span>
<span class="n">rest_system</span><span class="o">.</span><span class="n">addForce</span><span class="p">(</span><span class="n">rest_torsion_force</span><span class="p">)</span>

<span class="c1"># Add global parameters</span>
<span class="n">rest_torsion_force</span><span class="o">.</span><span class="n">addGlobalParameter</span><span class="p">(</span><span class="s2">&quot;lambda_rest_torsions&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># Add per-torsion parameters for rest scaling</span>
<span class="n">rest_torsion_force</span><span class="o">.</span><span class="n">addPerTorsionParameter</span><span class="p">(</span><span class="s2">&quot;is_rest&quot;</span><span class="p">)</span>
<span class="n">rest_torsion_force</span><span class="o">.</span><span class="n">addPerTorsionParameter</span><span class="p">(</span><span class="s2">&quot;is_inter&quot;</span><span class="p">)</span>
<span class="n">rest_torsion_force</span><span class="o">.</span><span class="n">addPerTorsionParameter</span><span class="p">(</span><span class="s2">&quot;is_nonrest&quot;</span><span class="p">)</span>

<span class="c1"># Add per-torsion parameters for defining torsion energy</span>
<span class="n">rest_torsion_force</span><span class="o">.</span><span class="n">addPerTorsionParameter</span><span class="p">(</span><span class="s1">&#39;periodicity&#39;</span><span class="p">)</span>
<span class="n">rest_torsion_force</span><span class="o">.</span><span class="n">addPerTorsionParameter</span><span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">)</span> <span class="c1"># phase offset</span>
<span class="n">rest_torsion_force</span><span class="o">.</span><span class="n">addPerTorsionParameter</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">)</span> <span class="c1"># force constant</span>

<span class="c1"># Get vanilla system torsion force</span>
<span class="n">torsion_force</span> <span class="o">=</span> <span class="n">system_forces</span><span class="p">[</span><span class="s1">&#39;PeriodicTorsionForce&#39;</span><span class="p">]</span>

<span class="c1"># Set periodicity</span>
<span class="k">if</span> <span class="n">torsion_force</span><span class="o">.</span><span class="n">usesPeriodicBoundaryConditions</span><span class="p">():</span>
    <span class="n">rest_torsion_force</span><span class="o">.</span><span class="n">setUsesPeriodicBoundaryConditions</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Add torsions to rest_system</span>
<span class="k">for</span> <span class="n">torsion_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">torsion_force</span><span class="o">.</span><span class="n">getNumTorsions</span><span class="p">()):</span>
    <span class="c1"># Get the torsion parameters and rest id</span>
    <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="n">periodicity</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="n">torsion_force</span><span class="o">.</span><span class="n">getTorsionParameters</span><span class="p">(</span><span class="n">torsion_idx</span><span class="p">)</span>
    <span class="n">idx_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">])</span>
    <span class="n">rest_id</span> <span class="o">=</span> <span class="n">get_rest_identifier</span><span class="p">(</span><span class="n">idx_set</span><span class="p">,</span> <span class="n">rest_atoms</span><span class="p">)</span>

    <span class="c1"># Add torsion</span>
    <span class="n">torsion_term</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="n">rest_id</span> <span class="o">+</span> <span class="p">[</span><span class="n">periodicity</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">K</span><span class="p">])</span>
    <span class="n">rest_torsion_force</span><span class="o">.</span><span class="n">addTorsion</span><span class="p">(</span><span class="o">*</span><span class="n">torsion_term</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<p>Finally, we construct the REST system’s nonbonded force (i.e., a <code class="docutils literal notranslate"><span class="pre">NonbondedForce</span></code>) by copying the nonbonded method and related parameters from the vanilla system’s nonbonded force. We add two global parameters (<code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code> and <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code>) to act as scale factors for nonbonded interactions involving REST atoms.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create nonbonded force</span>
<span class="n">rest_nonbonded_force</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">NonbondedForce</span><span class="p">()</span>
<span class="n">rest_system</span><span class="o">.</span><span class="n">addForce</span><span class="p">(</span><span class="n">rest_nonbonded_force</span><span class="p">)</span>

<span class="c1"># Get vanilla system nonbonded force</span>
<span class="n">nonbonded_force</span> <span class="o">=</span> <span class="n">system_forces</span><span class="p">[</span><span class="s1">&#39;NonbondedForce&#39;</span><span class="p">]</span>

<span class="c1"># Set the nonbonded method and related parameters</span>
<span class="n">nonbonded_method</span> <span class="o">=</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getNonbondedMethod</span><span class="p">()</span>
<span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">setNonbondedMethod</span><span class="p">(</span><span class="n">nonbonded_method</span><span class="p">)</span>
<span class="k">if</span> <span class="n">nonbonded_method</span> <span class="o">!=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">NonbondedForce</span><span class="o">.</span><span class="n">NoCutoff</span><span class="p">:</span>
    <span class="n">epsilon_solvent</span> <span class="o">=</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getReactionFieldDielectric</span><span class="p">()</span>
    <span class="n">cutoff</span> <span class="o">=</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getCutoffDistance</span><span class="p">()</span>
    <span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">setReactionFieldDielectric</span><span class="p">(</span><span class="n">epsilon_solvent</span><span class="p">)</span>
    <span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">setCutoffDistance</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span>
<span class="k">if</span> <span class="n">nonbonded_method</span> <span class="ow">in</span> <span class="p">[</span><span class="n">openmm</span><span class="o">.</span><span class="n">NonbondedForce</span><span class="o">.</span><span class="n">PME</span><span class="p">,</span> <span class="n">openmm</span><span class="o">.</span><span class="n">NonbondedForce</span><span class="o">.</span><span class="n">Ewald</span><span class="p">]:</span>
    <span class="p">[</span><span class="n">alpha_ewald</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">]</span> <span class="o">=</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getPMEParameters</span><span class="p">()</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getEwaldErrorTolerance</span><span class="p">()</span>
    <span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">setPMEParameters</span><span class="p">(</span><span class="n">alpha_ewald</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">)</span>
    <span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">setEwaldErrorTolerance</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>

<span class="c1"># Copy switching function from vanilla system</span>
<span class="n">switch_bool</span> <span class="o">=</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getUseSwitchingFunction</span><span class="p">()</span>
<span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">setUseSwitchingFunction</span><span class="p">(</span><span class="n">switch_bool</span><span class="p">)</span>
<span class="k">if</span> <span class="n">switch_bool</span><span class="p">:</span>
    <span class="n">switching_distance</span> <span class="o">=</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getSwitchingDistance</span><span class="p">()</span>
    <span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">setSwitchingDistance</span><span class="p">(</span><span class="n">switching_distance</span><span class="p">)</span>

<span class="c1"># Copy dispersion correction</span>
<span class="n">dispersion_bool</span> <span class="o">=</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getUseDispersionCorrection</span><span class="p">()</span>
<span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">setUseDispersionCorrection</span><span class="p">(</span><span class="n">dispersion_bool</span><span class="p">)</span>

<span class="c1"># Add global parameters</span>
<span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">addGlobalParameter</span><span class="p">(</span><span class="s1">&#39;lambda_rest_electrostatics&#39;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
<span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">addGlobalParameter</span><span class="p">(</span><span class="s1">&#39;lambda_rest_sterics&#39;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
<br/><br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
1
</pre></div></div>
</div>
<p>We then copy the nonbonded particles and exceptions from the vanilla system’s nonbonded force to the rest system’s nonbonded force. We add offsets to the particles and exceptions in order to apply REST scaling. The offsets for electrostatics and sterics depend on <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code> and <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code>, respectively. The offsets for REST and inter exceptions conveniently depend on <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code> and <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code>, respectively (derivation available in
the Appendix).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Add nonbondeds to rest_system</span>
<span class="k">for</span> <span class="n">particle_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getNumParticles</span><span class="p">()):</span>
    <span class="c1"># Get the nonbonded parameters and rest id</span>
    <span class="n">q</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getParticleParameters</span><span class="p">(</span><span class="n">particle_idx</span><span class="p">)</span>
    <span class="n">rest_id</span> <span class="o">=</span> <span class="n">get_rest_identifier</span><span class="p">(</span><span class="n">particle_idx</span><span class="p">,</span> <span class="n">rest_atoms</span><span class="p">)</span>

    <span class="c1"># Add particles and offsets</span>
    <span class="k">if</span> <span class="n">rest_id</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span> <span class="c1"># nonrest</span>
        <span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">addParticle</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span> <span class="c1"># rest</span>
        <span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">addParticle</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
        <span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">addParticleParameterOffset</span><span class="p">(</span><span class="s1">&#39;lambda_rest_electrostatics&#39;</span><span class="p">,</span> <span class="n">particle_idx</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">*</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">addParticleParameterOffset</span><span class="p">(</span><span class="s1">&#39;lambda_rest_sterics&#39;</span><span class="p">,</span> <span class="n">particle_idx</span><span class="p">,</span> <span class="n">q</span><span class="o">*</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>

<span class="c1"># Handle exceptions</span>
<span class="k">for</span> <span class="n">exception_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getNumExceptions</span><span class="p">()):</span>
    <span class="c1"># Get exception parameters and rest id</span>
    <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">chargeProd</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getExceptionParameters</span><span class="p">(</span><span class="n">exception_idx</span><span class="p">)</span>
    <span class="n">idx_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">])</span>
    <span class="n">rest_id</span> <span class="o">=</span> <span class="n">get_rest_identifier</span><span class="p">(</span><span class="n">idx_set</span><span class="p">,</span> <span class="n">rest_atoms</span><span class="p">)</span>

    <span class="c1"># Add exceptions and offsets</span>
    <span class="n">exc_idx</span> <span class="o">=</span> <span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">addException</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">chargeProd</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rest_id</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span> <span class="c1"># nonrest</span>
        <span class="k">pass</span>

    <span class="k">elif</span> <span class="n">rest_id</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span> <span class="c1"># rest</span>
        <span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">addExceptionParameterOffset</span><span class="p">(</span><span class="s1">&#39;lambda_rest_sterics&#39;</span><span class="p">,</span> <span class="n">exc_idx</span><span class="p">,</span> <span class="n">chargeProd</span><span class="p">,</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">rest_id</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span> <span class="c1"># inter</span>
        <span class="n">rest_nonbonded_force</span><span class="o">.</span><span class="n">addExceptionParameterOffset</span><span class="p">(</span><span class="s1">&#39;lambda_rest_electrostatics&#39;</span><span class="p">,</span> <span class="n">exc_idx</span><span class="p">,</span> <span class="n">chargeProd</span><span class="p">,</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<p>We’ve now finished building a REST-capable OpenMM system for villin, <code class="docutils literal notranslate"><span class="pre">rest_system</span></code>!</p>
</section>
<section id="03---Run-replica-exchange">
<h2>03 - Run replica exchange<a class="headerlink" href="#03---Run-replica-exchange" title="Link to this heading">¶</a></h2>
<p>This section requires <a class="reference external" href="https://openmmtools.readthedocs.io/en/stable/index.html">openmmtools</a></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>mamba<span class="w"> </span>install<span class="w"> </span>-qy<span class="w"> </span>-c<span class="w"> </span>conda-forge<span class="w"> </span>openmmtools
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openmmtools.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">kB</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openmmtools</span><span class="w"> </span><span class="kn">import</span> <span class="n">cache</span><span class="p">,</span> <span class="n">mcmc</span><span class="p">,</span> <span class="n">multistate</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openmmtools.multistate</span><span class="w"> </span><span class="kn">import</span> <span class="n">ReplicaExchangeSampler</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openmmtools.states</span><span class="w"> </span><span class="kn">import</span> <span class="n">GlobalParameterState</span><span class="p">,</span> <span class="n">SamplerState</span><span class="p">,</span> <span class="n">ThermodynamicState</span><span class="p">,</span> <span class="n">CompoundThermodynamicState</span>
</pre></div>
</div>
</div>
<p>Now, we would like to use <code class="docutils literal notranslate"><span class="pre">rest_system</span></code> to run REST, which consists of using replica exchange to sample a number of thermodynamic states, each of which has a different REST-modified Hamiltonian. To construct each of the thermodynamic states, we define a class called <code class="docutils literal notranslate"><span class="pre">RESTState</span></code> that creates a “state” (aka version of the system) with a particular set of global parameters (<code class="docutils literal notranslate"><span class="pre">lambda_rest_bonds</span></code>, <code class="docutils literal notranslate"><span class="pre">lambda_rest_angles</span></code>, <code class="docutils literal notranslate"><span class="pre">lambda_rest_torsions</span></code>, <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code>,
<code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code>). To set the global parameters for each thermodynamic state, we just need to supply <code class="docutils literal notranslate"><span class="pre">beta_m</span></code> (proportional to the temperature <code class="docutils literal notranslate"><span class="pre">m</span></code> we wish to scale to) and <code class="docutils literal notranslate"><span class="pre">beta_0</span></code> (proportional to the temperature of distribution of interest), where <code class="docutils literal notranslate"><span class="pre">beta</span></code> = <span class="math notranslate nohighlight">\(\frac{1}{k_b T}\)</span>. See Wang et al. 2011 (DOI: 10.1021/jp204407d) for more details.</p>
<p>Given <code class="docutils literal notranslate"><span class="pre">beta_m</span></code> and <code class="docutils literal notranslate"><span class="pre">beta_0</span></code>, the <code class="docutils literal notranslate"><span class="pre">RESTState</span></code> takes care of actually computing the value for each global parameter (based on <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">functions</span></code>). For <code class="docutils literal notranslate"><span class="pre">lambda_rest_bonds</span></code>, <code class="docutils literal notranslate"><span class="pre">lambda_rest_angles</span></code>, <code class="docutils literal notranslate"><span class="pre">lambda_rest_torsions</span></code>, the value will be computed according to <span class="math notranslate nohighlight">\(\sqrt{\frac{\beta_m}{\beta_0}}\)</span>. For <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code>, the value will be computed as <span class="math notranslate nohighlight">\(\sqrt{\frac{\beta_m}{\beta_0}} - 1\)</span>. For <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code>, the value will be computed as
<span class="math notranslate nohighlight">\(\frac{\beta_m}{\beta_0} - 1\)</span>. See Appendix for derivation of the functions for <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code> and <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RESTState</span><span class="p">(</span><span class="n">GlobalParameterState</span><span class="p">):</span>
    <span class="n">lambda_rest_bonds</span> <span class="o">=</span> <span class="n">GlobalParameterState</span><span class="o">.</span><span class="n">GlobalParameter</span><span class="p">(</span><span class="s1">&#39;lambda_rest_bonds&#39;</span><span class="p">,</span> <span class="n">standard_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">lambda_rest_angles</span> <span class="o">=</span> <span class="n">GlobalParameterState</span><span class="o">.</span><span class="n">GlobalParameter</span><span class="p">(</span><span class="s1">&#39;lambda_rest_angles&#39;</span><span class="p">,</span> <span class="n">standard_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">lambda_rest_torsions</span> <span class="o">=</span> <span class="n">GlobalParameterState</span><span class="o">.</span><span class="n">GlobalParameter</span><span class="p">(</span><span class="s1">&#39;lambda_rest_torsions&#39;</span><span class="p">,</span> <span class="n">standard_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">lambda_rest_electrostatics</span> <span class="o">=</span> <span class="n">GlobalParameterState</span><span class="o">.</span><span class="n">GlobalParameter</span><span class="p">(</span><span class="s1">&#39;lambda_rest_electrostatics&#39;</span><span class="p">,</span> <span class="n">standard_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">lambda_rest_sterics</span> <span class="o">=</span> <span class="n">GlobalParameterState</span><span class="o">.</span><span class="n">GlobalParameter</span><span class="p">(</span><span class="s1">&#39;lambda_rest_sterics&#39;</span><span class="p">,</span> <span class="n">standard_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_rest_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta_m</span><span class="p">,</span> <span class="n">beta_0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all defined lambda parameters to the given value.</span>

<span class="sd">        The undefined parameters (i.e. those being set to None) remain undefined.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_value : float</span>
<span class="sd">            The new value for all defined parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lambda_functions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lambda_rest_bonds&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">beta_m</span><span class="p">,</span> <span class="n">beta_0</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">beta_m</span> <span class="o">/</span> <span class="n">beta_0</span><span class="p">),</span>
                 <span class="s1">&#39;lambda_rest_angles&#39;</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">beta_m</span><span class="p">,</span> <span class="n">beta_0</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">beta_m</span> <span class="o">/</span> <span class="n">beta_0</span><span class="p">),</span>
                 <span class="s1">&#39;lambda_rest_torsions&#39;</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">beta_m</span><span class="p">,</span> <span class="n">beta_0</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">beta_m</span> <span class="o">/</span> <span class="n">beta_0</span><span class="p">),</span>
                 <span class="s1">&#39;lambda_rest_electrostatics&#39;</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">beta_m</span><span class="p">,</span> <span class="n">beta_0</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">beta_m</span> <span class="o">/</span> <span class="n">beta_0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="s1">&#39;lambda_rest_sterics&#39;</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">beta_m</span><span class="p">,</span> <span class="n">beta_0</span> <span class="p">:</span> <span class="n">beta_m</span> <span class="o">/</span> <span class="n">beta_0</span> <span class="o">-</span> <span class="mi">1</span>
                 <span class="p">}</span>

        <span class="k">for</span> <span class="n">parameter_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_value</span> <span class="o">=</span> <span class="n">lambda_functions</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">](</span><span class="n">beta_m</span><span class="p">,</span> <span class="n">beta_0</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_name</span><span class="p">,</span> <span class="n">new_value</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>We next determine the number of replicas and states (both are 12) and choose the <code class="docutils literal notranslate"><span class="pre">T_min</span></code> (the minimum temperature, i.e., the temperature of the desired distribution) and <code class="docutils literal notranslate"><span class="pre">T_max</span></code> (the maximum temperature to be scaled to during REST) to be 300 and 600 Kelvin, respectively. We set the temperatures of each thermodynamic state to be exponentially spaced between 300 and 600 Kelvin.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set temperatures for each thermodynamic state</span>
<span class="n">n_replicas</span> <span class="o">=</span> <span class="mi">12</span>  <span class="c1"># Number of temperature replicas</span>
<span class="n">T_min</span> <span class="o">=</span> <span class="mi">300</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">kelvin</span>  <span class="c1"># Minimum temperature (i.e., temperature of desired distribution)</span>
<span class="n">T_max</span> <span class="o">=</span> <span class="mi">600</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">kelvin</span>  <span class="c1"># Maximum temperature</span>
<span class="n">temperatures</span> <span class="o">=</span> <span class="p">[</span><span class="n">T_min</span> <span class="o">+</span> <span class="p">(</span><span class="n">T_max</span> <span class="o">-</span> <span class="n">T_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_replicas</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">e</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_replicas</span><span class="p">)]</span>
<br/><br/></pre></div>
</div>
</div>
<p>We now create a reference thermodynamic state (i.e., <code class="docutils literal notranslate"><span class="pre">RESTState</span></code>) from the <code class="docutils literal notranslate"><span class="pre">rest_system</span></code> and use that state to create OpenMMTools <code class="docutils literal notranslate"><span class="pre">ThermodynamicState</span></code> and <code class="docutils literal notranslate"><span class="pre">CompoundThermodynamicState</span></code> objects which will be used with other OpenMMTools objects below to run replica exchange.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create reference thermodynamic state</span>
<span class="n">rest_state</span> <span class="o">=</span> <span class="n">RESTState</span><span class="o">.</span><span class="n">from_system</span><span class="p">(</span><span class="n">rest_system</span><span class="p">)</span>
<span class="n">thermostate</span> <span class="o">=</span> <span class="n">ThermodynamicState</span><span class="p">(</span><span class="n">rest_system</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">T_min</span><span class="p">)</span>
<span class="n">compound_thermodynamic_state</span> <span class="o">=</span> <span class="n">CompoundThermodynamicState</span><span class="p">(</span><span class="n">thermostate</span><span class="p">,</span> <span class="n">composable_states</span><span class="o">=</span><span class="p">[</span><span class="n">rest_state</span><span class="p">])</span>
<br/></pre></div>
</div>
</div>
<p>Using the reference thermodynamic state, we create a list of 12 thermodynamic states, one for each temperature in <code class="docutils literal notranslate"><span class="pre">temperatures</span></code>. Each of these thermodynamic states also has an associated OpenMMTools <code class="docutils literal notranslate"><span class="pre">SamplerState</span></code> object which contains the corresponding box vectors and minimized positions.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create thermodynamic states</span>
<span class="n">sampler_state</span> <span class="o">=</span>  <span class="n">SamplerState</span><span class="p">(</span><span class="n">pdb</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">box_vectors</span><span class="o">=</span><span class="n">rest_system</span><span class="o">.</span><span class="n">getDefaultPeriodicBoxVectors</span><span class="p">())</span>
<span class="n">beta_0</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">kB</span><span class="o">*</span><span class="n">T_min</span><span class="p">)</span>
<span class="n">thermodynamic_state_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">sampler_state_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">temperature</span> <span class="ow">in</span> <span class="n">temperatures</span><span class="p">:</span>
    <span class="c1"># Create a thermodynamic state with REST interactions scaled to the given temperature</span>
    <span class="n">beta_m</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">kB</span><span class="o">*</span><span class="n">temperature</span><span class="p">)</span>
    <span class="n">compound_thermodynamic_state_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">compound_thermodynamic_state</span><span class="p">)</span>
    <span class="n">compound_thermodynamic_state_copy</span><span class="o">.</span><span class="n">set_rest_parameters</span><span class="p">(</span><span class="n">beta_m</span><span class="p">,</span> <span class="n">beta_0</span><span class="p">)</span>
    <span class="n">thermodynamic_state_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compound_thermodynamic_state_copy</span><span class="p">)</span>

    <span class="c1"># Generate a sampler_state with minimized positions</span>
    <span class="n">context</span><span class="p">,</span> <span class="n">integrator</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">global_context_cache</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="n">compound_thermodynamic_state_copy</span><span class="p">)</span>
    <span class="n">sampler_state</span><span class="o">.</span><span class="n">apply_to_context</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">ignore_velocities</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">openmm</span><span class="o">.</span><span class="n">LocalEnergyMinimizer</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
    <span class="n">sampler_state</span><span class="o">.</span><span class="n">update_from_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
    <span class="n">sampler_state_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sampler_state</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>We now create OpenMMTools objects to run replica exchange. We instantiate a <code class="docutils literal notranslate"><span class="pre">LangevinDynamicsMove</span></code> which tells the <code class="docutils literal notranslate"><span class="pre">ReplicaExchangeSampler</span></code> to run 1 ps of molecular dynamics (here, Langevin dynamics) between swap attempts. We instantiate the <code class="docutils literal notranslate"><span class="pre">ReplicaExchangeSampler</span></code> with 100 iterations (i.e., swap attempts). We then initialize a <code class="docutils literal notranslate"><span class="pre">MultiStateReporter</span></code> to save critical information from the replica exchange simulation, e.g., reduced potentials, positions, box vectors, etc. And finally, we
run the REST simulation!</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up sampler</span>
<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">()</span>
<span class="n">_logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">move</span> <span class="o">=</span> <span class="n">mcmc</span><span class="o">.</span><span class="n">LangevinDynamicsMove</span><span class="p">(</span><span class="n">timestep</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">femtoseconds</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">250</span><span class="p">)</span> <span class="c1"># each move is 1 ps</span>
<span class="n">simulation</span> <span class="o">=</span> <span class="n">ReplicaExchangeSampler</span><span class="p">(</span><span class="n">mcmc_moves</span><span class="o">=</span><span class="n">move</span><span class="p">,</span> <span class="n">number_of_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="c1"># Run repex</span>
<span class="n">reporter_file</span> <span class="o">=</span> <span class="s2">&quot;test.nc&quot;</span>
<span class="n">reporter</span> <span class="o">=</span> <span class="n">multistate</span><span class="o">.</span><span class="n">MultiStateReporter</span><span class="p">(</span><span class="n">reporter_file</span><span class="p">,</span> <span class="n">checkpoint_interval</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">thermodynamic_states</span><span class="o">=</span><span class="n">thermodynamic_state_list</span><span class="p">,</span>
                  <span class="n">sampler_states</span><span class="o">=</span><span class="n">sampler_state_list</span><span class="p">,</span>
                  <span class="n">storage</span><span class="o">=</span><span class="n">reporter</span><span class="p">)</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
Warning: The openmmtools.multistate API is experimental and may change in future releases
/bin/sh: nvidia-smi: command not found
Warning: The openmmtools.multistate API is experimental and may change in future releases
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Please cite the following:

        Friedrichs MS, Eastman P, Vaidyanathan V, Houston M, LeGrand S, Beberg AL, Ensign DL, Bruns CM, and Pande VS. Accelerating molecular dynamic simulations on graphics processing unit. J. Comput. Chem. 30:864, 2009. DOI: 10.1002/jcc.21209
        Eastman P and Pande VS. OpenMM: A hardware-independent framework for molecular simulations. Comput. Sci. Eng. 12:34, 2010. DOI: 10.1109/MCSE.2010.27
        Eastman P and Pande VS. Efficient nonbonded interactions for molecular dynamics on a graphics processing unit. J. Comput. Chem. 31:1268, 2010. DOI: 10.1002/jcc.21413
        Eastman P and Pande VS. Constant constraint matrix approximation: A robust, parallelizable constraint method for molecular simulations. J. Chem. Theor. Comput. 6:434, 2010. DOI: 10.1021/ct900463w
        Chodera JD and Shirts MR. Replica exchange and expanded ensemble simulations as Gibbs multistate: Simple improvements for enhanced mixing. J. Chem. Phys., 135:194110, 2011. DOI:10.1063/1.3660669

</pre></div></div>
</div>
</section>
<section id="Appendix">
<h2>Appendix<a class="headerlink" href="#Appendix" title="Link to this heading">¶</a></h2>
<section id="REST-potential">
<h3>REST potential<a class="headerlink" href="#REST-potential" title="Link to this heading">¶</a></h3>
<p>According to Wang et al. 2011 (DOI: 10.1021/jp204407d, available at: <a class="reference external" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3172817/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3172817/</a>), the modified REST potential is defined as:</p>
<p><span class="math notranslate nohighlight">\(U_\text{total}(x) = \frac{\beta_m}{\beta_0} U_\text{REST}(x) + \sqrt{\frac{\beta_m}{\beta_0}} U_\text{inter}(x) + U_\text{non-REST}(x)\)</span></p>
<p>where <span class="math notranslate nohighlight">\(U_\text{total}(x)\)</span> represents the total potential energy of configuration <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(U_\text{REST}(x)\)</span> represents the potential energy of interactions between REST atoms, <span class="math notranslate nohighlight">\(U_\text{inter}(x)\)</span> represents the potential energy of interactions between REST and non-REST atoms (i.e., “inter”), and <span class="math notranslate nohighlight">\(U_\text{non-REST}(x)\)</span> represents interactions between non-REST atoms.</p>
</section>
<section id="Electrostatic-interactions">
<h3>Electrostatic interactions<a class="headerlink" href="#Electrostatic-interactions" title="Link to this heading">¶</a></h3>
<p>For the <code class="docutils literal notranslate"><span class="pre">NonbondedForce</span></code>, we use offsets to scale the energies according to REST. We first explore how offsets are applied for electrostatic interactions.</p>
<p>For electrostatics, the potential energy is defined by: <span class="math notranslate nohighlight">\(U_\text{elec} = \frac{q_1 q_2}{4\pi\epsilon_0}\frac{1}{r}\)</span> where <span class="math notranslate nohighlight">\(q\)</span> is the charge of an atom, <span class="math notranslate nohighlight">\(\epsilon_0\)</span> is the vacuum permittivity, and <span class="math notranslate nohighlight">\(r\)</span> is the distance between atoms.</p>
<p>We apply offsets to the charge (<span class="math notranslate nohighlight">\(q\)</span>) according to:</p>
<p>charge = baseCharge + lambda_rest_electrostatics*chargeScale</p>
<p>where <code class="docutils literal notranslate"><span class="pre">baseCharge</span></code> is the current charge value for the atom in the <code class="docutils literal notranslate"><span class="pre">NonbondedForce</span></code>, <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code> is a global parameter and must be between 0 and 1, and <code class="docutils literal notranslate"><span class="pre">chargeScale</span></code> (when multiplied with <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code>) controls the value to be added to <code class="docutils literal notranslate"><span class="pre">baseCharge</span></code>.</p>
<p>We set <code class="docutils literal notranslate"><span class="pre">chargeScale</span></code> = <code class="docutils literal notranslate"><span class="pre">baseCharge</span></code> and derive the functional form for <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code> to enable REST scaling for each of the following cases:</p>
<p>Case 1: Both atoms are non-REST</p>
<ul class="simple">
<li><p>The interaction should not be scaled, meaning no offset is needed.</p></li>
</ul>
<p>Case 2: Atom 1 is non-REST, Atom 2 is REST (or vice-versa)</p>
<ul>
<li><p>We can express the electrostatics energy as</p>
<p><span class="math notranslate nohighlight">\(U_\text{elec} =  \sqrt{\frac{\beta_m}{\beta_0}} \frac{q_1 q_2}{4\pi\epsilon_0}\frac{1}{r} = \frac{q_1 (q_2 + \lambda q_2)}{4\pi\epsilon_0}\frac{1}{r}\)</span></p>
</li>
<li><p>which is equivalent to</p>
<p><span class="math notranslate nohighlight">\(U_\text{elec} =  \sqrt{\frac{\beta_m}{\beta_0}} = 1 + \lambda\)</span></p>
</li>
<li><p>meaning</p>
<p><span class="math notranslate nohighlight">\(\lambda = \sqrt{\frac{\beta_m}{\beta_0}} - 1\)</span></p>
</li>
</ul>
<p>Case 3: Both atoms are REST</p>
<ul>
<li><p>We can express the electrostatics energy as</p>
<p><span class="math notranslate nohighlight">\(U_\text{elec} =  \frac{\beta_m}{\beta_0} \frac{q_1 q_2}{4\pi\epsilon_0}\frac{1}{r} = \frac{(q_1 + q_1 \lambda) (q_2 + \lambda q_2)}{4\pi\epsilon_0}\frac{1}{r}\)</span></p>
</li>
<li><p>which is equivalent to</p>
<p><span class="math notranslate nohighlight">\(U_\text{elec} =  \frac{\beta_m}{\beta_0} \frac{q_1 q_2}{4\pi\epsilon_0}\frac{1}{r} = \frac{q_1 q_2 (1 + \lambda)^2}{4\pi\epsilon_0}\frac{1}{r}\)</span></p>
</li>
<li><p>meaning</p>
<p><span class="math notranslate nohighlight">\(\lambda = \sqrt{\frac{\beta_m}{\beta_0}} - 1\)</span></p>
</li>
</ul>
<p>In both cases 2 and 3, <span class="math notranslate nohighlight">\(\lambda = \sqrt{\frac{\beta_m}{\beta_0}} - 1\)</span>. We use this as our lambda function for <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code>.</p>
</section>
<section id="Steric-interactions">
<h3>Steric interactions<a class="headerlink" href="#Steric-interactions" title="Link to this heading">¶</a></h3>
<p>We also use offsets to modify steric interactions involving REST atoms.</p>
<p>For sterics, the potential energy is defined by: <span class="math notranslate nohighlight">\(U_\text{sterics} = 4\epsilon\left(\left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^6\right)\)</span> where <span class="math notranslate nohighlight">\(\sigma\)</span> is the distance at which the energy equals zero, <span class="math notranslate nohighlight">\(r\)</span> is the distance between atoms, and <span class="math notranslate nohighlight">\(\epsilon\)</span> is the strength of the interaction (computed from the the <span class="math notranslate nohighlight">\(\epsilon\)</span>s of atoms 1 and 2: <span class="math notranslate nohighlight">\(\epsilon = \sqrt{\epsilon_1\epsilon_2}\)</span>).</p>
<p>We apply offsets to <span class="math notranslate nohighlight">\(\epsilon_i\)</span> according to:</p>
<p>epsilon = baseEpsilon + lambda_rest_sterics*epsilonScale$</p>
<p>where <code class="docutils literal notranslate"><span class="pre">baseEpsilon</span></code> is the current <span class="math notranslate nohighlight">\(\epsilon\)</span> value for the atom in the <code class="docutils literal notranslate"><span class="pre">NonbondedForce</span></code>, <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code> is a global parameter and must be between 0 and 1, and <code class="docutils literal notranslate"><span class="pre">epsilonScale</span></code> (when multiplied with <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code>) controls the value to be added to <code class="docutils literal notranslate"><span class="pre">baseEpsilon</span></code>.</p>
<p>We set <code class="docutils literal notranslate"><span class="pre">epsilonScale</span></code> = <code class="docutils literal notranslate"><span class="pre">baseEpsilon</span></code> and derive the functional form for <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code> to enable REST scaling for each of the following cases:</p>
<p>Case 1: Both atoms are non-REST</p>
<ul class="simple">
<li><p>The interaction should not be scaled, meaning no offset is needed.</p></li>
</ul>
<p>Case 2: Atom 1 is non-REST, Atom 2 is REST (or vice-versa)</p>
<ul>
<li><p>We can express the sterics energy as</p>
<p><span class="math notranslate nohighlight">\(U_\text{sterics} =  \sqrt{\frac{\beta_m}{\beta_0}} \cdot 4\sqrt{\epsilon_1\epsilon_2}\left(\left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^6\right) = 4\sqrt{\epsilon_1(\epsilon_2 + \lambda\epsilon_2)}\left(\left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^6\right)\)</span></p>
</li>
<li><p>which is equivalent to</p>
<p><span class="math notranslate nohighlight">\(U_\text{sterics} =  \sqrt{\frac{\beta_m}{\beta_0}} \cdot \sqrt{\epsilon_1\epsilon_2} = \sqrt{\epsilon_1\epsilon_2(1 + \lambda)}\)</span></p>
</li>
<li><p>meaning</p>
<p><span class="math notranslate nohighlight">\(\lambda = \frac{\beta_m}{\beta_0} - 1\)</span></p>
</li>
</ul>
<p>Case 3: Both atoms are REST</p>
<ul>
<li><p>We can express the sterics energy as</p>
<p><span class="math notranslate nohighlight">\(U_\text{sterics} =  \frac{\beta_m}{\beta_0} \cdot 4\sqrt{\epsilon_1\epsilon_2}\left(\left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^6\right) = 4\sqrt{\epsilon_1\epsilon_2 (1 + \lambda)^2}\left(\left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^6\right)\)</span></p>
</li>
<li><p>which is equivalent to</p>
<p><span class="math notranslate nohighlight">\(U_\text{sterics} =  \frac{\beta_m}{\beta_0} \cdot \sqrt{\epsilon_1\epsilon_2} = \sqrt{\epsilon_1\epsilon_2(1 + \lambda)^2}\)</span></p>
</li>
<li><p>meaning</p>
<p><span class="math notranslate nohighlight">\(\lambda = \frac{\beta_m}{\beta_0} - 1\)</span></p>
</li>
</ul>
<p>In both cases 2 and 3, <span class="math notranslate nohighlight">\(\lambda = \frac{\beta_m}{\beta_0} - 1\)</span>. We use this as our lambda function for <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code>.</p>
</section>
<section id="Electrostatic-exceptions">
<h3>Electrostatic exceptions<a class="headerlink" href="#Electrostatic-exceptions" title="Link to this heading">¶</a></h3>
<p>We also use offsets to modify electrostatics exceptions involving REST atoms.</p>
<p>For electrostatic exceptions, the functional form of the potential energy is the same as for electrostatic interactions, except that for exceptions, the functional form accepts the charge product directly, instead of the individual charges for each atom. Therefore, <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code> will scale the product, not each individual charge.</p>
<p>We apply offsets to the chargeProd (<span class="math notranslate nohighlight">\(q_1 q_2\)</span>) according to:</p>
<p>chargeProd = baseChargeProd + lambda_rest_electrostatics*chargeProdScale</p>
<p>where <code class="docutils literal notranslate"><span class="pre">baseChargeProd</span></code> is the current charge product for the two atoms in the <code class="docutils literal notranslate"><span class="pre">NonbondedForce</span></code>, <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code> is a global parameter and must be between 0 and 1, and <code class="docutils literal notranslate"><span class="pre">chargeProdScale</span></code> (when multiplied with <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code>) controls the value to be added to <code class="docutils literal notranslate"><span class="pre">baseChargeProd</span></code>.</p>
<p>We set <code class="docutils literal notranslate"><span class="pre">chargeProdScale</span></code> = <code class="docutils literal notranslate"><span class="pre">baseChargeProd</span></code> and derive the functional form for the rest scale factor (i.e., <span class="math notranslate nohighlight">\(\lambda\)</span>) for each of the following cases:</p>
<p>Case 1: Both atoms are non-REST</p>
<ul class="simple">
<li><p>The interaction should not be scaled, meaning no offset is needed.</p></li>
</ul>
<p>Case 2: Atom 1 is non-REST, Atom 2 is REST (or vice-versa)</p>
<ul>
<li><p>We can express the electrostatics energy as</p>
<p><span class="math notranslate nohighlight">\(U_\text{elec} =  \sqrt{\frac{\beta_m}{\beta_0}} \frac{q_1 q_2}{4\pi\epsilon_0}\frac{1}{r} = \frac{q_1 q_2 + \lambda q_1 q_2}{4\pi\epsilon_0}\frac{1}{r}\)</span></p>
</li>
<li><p>which is equivalent to</p>
<p><span class="math notranslate nohighlight">\(U_\text{elec} =  \sqrt{\frac{\beta_m}{\beta_0}} = 1 + \lambda\)</span></p>
</li>
<li><p>meaning</p>
<p><span class="math notranslate nohighlight">\(\lambda = \sqrt{\frac{\beta_m}{\beta_0}} - 1\)</span></p>
</li>
</ul>
<p>Case 3: Both atoms are REST</p>
<ul>
<li><p>We can express the electrostatics energy as</p>
<p><span class="math notranslate nohighlight">\(U_\text{elec} =  \frac{\beta_m}{\beta_0} \frac{q_1 q_2}{4\pi\epsilon_0}\frac{1}{r} = \frac{q_1 q_2 + \lambda q_1 q_2}{4\pi\epsilon_0}\frac{1}{r}\)</span></p>
</li>
<li><p>which is equivalent to</p>
<p><span class="math notranslate nohighlight">\(U_\text{elec} =  \frac{\beta_m}{\beta_0} = 1 + \lambda\)</span></p>
</li>
<li><p>meaning</p>
<p><span class="math notranslate nohighlight">\(\lambda = \frac{\beta_m}{\beta_0} - 1\)</span></p>
</li>
</ul>
<p>In case 2, <span class="math notranslate nohighlight">\(\lambda = \sqrt{\frac{\beta_m}{\beta_0}} - 1\)</span>, which matches the <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code> function. In case 3, <span class="math notranslate nohighlight">\(\lambda = \frac{\beta_m}{\beta_0} - 1\)</span>, which matches the <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code> function. We therefore use <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code> and <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code> to control the offsets for inter and REST exceptions, respectively.</p>
</section>
<section id="Steric-exceptions">
<h3>Steric exceptions<a class="headerlink" href="#Steric-exceptions" title="Link to this heading">¶</a></h3>
<p>We also use offsets to modify steric exceptions involving REST atoms.</p>
<p>For steric exceptions, the functional form of the potential energy is the same as for steric interactions, except that for exceptions, the functional form accepts the combined <span class="math notranslate nohighlight">\(\epsilon\)</span> directly, instead of the individual <span class="math notranslate nohighlight">\(\epsilon\)</span>s for each atom. Therefore, <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code> will scale the product, not each individual <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p>
<p>We apply offsets to the combined <span class="math notranslate nohighlight">\(\epsilon\)</span> (computed from <span class="math notranslate nohighlight">\(\sqrt{\epsilon_1 \epsilon_2}\)</span>) according to:</p>
<p>epsilonCombined = baseEpsilonCombined + lambda_rest_sterics*epsilonCombinedScale</p>
<p>where <code class="docutils literal notranslate"><span class="pre">baseEpsilonCombined</span></code> is the current combined epsilon for the two atoms in the <code class="docutils literal notranslate"><span class="pre">NonbondedForce</span></code>, <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code> is a global parameter and must be between 0 and 1, and <code class="docutils literal notranslate"><span class="pre">epsilonCombinedScale</span></code> (when multiplied with <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code>) controls the value to be added to <code class="docutils literal notranslate"><span class="pre">baseEpsilonCombined</span></code>.</p>
<p>We set <code class="docutils literal notranslate"><span class="pre">epsilonCombinedScale</span></code> = <code class="docutils literal notranslate"><span class="pre">baseEpsilonCombined</span></code> and derive the functional form for the rest scale factor (i.e., <span class="math notranslate nohighlight">\(\lambda\)</span>) for each of the following cases:</p>
<p>Case 1: Both atoms are non-REST</p>
<ul class="simple">
<li><p>The interaction should not be scaled, meaning no offset is needed.</p></li>
</ul>
<p>Case 2: Atom 1 is non-REST, Atom 2 is REST (or vice-versa)</p>
<ul>
<li><p>We can express the sterics energy as</p>
<p><span class="math notranslate nohighlight">\(U_\text{sterics} =  \sqrt{\frac{\beta_m}{\beta_0}} \cdot 4\sqrt{\epsilon_1\epsilon_2}\left(\left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^6\right) = 4\left(\sqrt{\epsilon_1\epsilon_2} + \lambda\sqrt{\epsilon_1\epsilon_2}\right)\left(\left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^6\right)\)</span></p>
</li>
<li><p>which is equivalent to</p>
<p><span class="math notranslate nohighlight">\(U_\text{sterics} =  \sqrt{\frac{\beta_m}{\beta_0}} \cdot \sqrt{\epsilon_1\epsilon_2} = \sqrt{\epsilon_1\epsilon_2}(1 + \lambda)\)</span></p>
</li>
<li><p>meaning</p>
<p><span class="math notranslate nohighlight">\(\lambda = \sqrt{\frac{\beta_m}{\beta_0}} - 1\)</span></p>
</li>
</ul>
<p>Case 3: Both atoms are REST</p>
<ul>
<li><p>We can express the sterics energy as</p>
<p><span class="math notranslate nohighlight">\(U_\text{sterics} =  \frac{\beta_m}{\beta_0} \cdot 4\sqrt{\epsilon_1\epsilon_2}\left(\left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^6\right) = 4\left(\sqrt{\epsilon_1\epsilon_2} + \lambda \sqrt{\epsilon_1\epsilon_2}\right)\left(\left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^6\right)\)</span></p>
</li>
<li><p>which is equivalent to</p>
<p><span class="math notranslate nohighlight">\(U_\text{sterics} =  \frac{\beta_m}{\beta_0} \cdot \sqrt{\epsilon_1\epsilon_2} = \sqrt{\epsilon_1\epsilon_2}(1 + \lambda)\)</span></p>
</li>
<li><p>meaning</p>
<p><span class="math notranslate nohighlight">\(\lambda = \frac{\beta_m}{\beta_0} - 1\)</span></p>
</li>
</ul>
<p>In case 2, <span class="math notranslate nohighlight">\(\lambda = \sqrt{\frac{\beta_m}{\beta_0}} - 1\)</span>, which matches the <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code> function. In case 3, <span class="math notranslate nohighlight">\(\lambda = \frac{\beta_m}{\beta_0} - 1\)</span>, which matches the <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code> function. We therefore use <code class="docutils literal notranslate"><span class="pre">lambda_rest_electrostatics</span></code> and <code class="docutils literal notranslate"><span class="pre">lambda_rest_sterics</span></code> to control the offsets for inter and REST exceptions, respectively.</p>
</section>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="Histone_methyltransferase_simulation_with_multisite_Zn2_structural_ions.html" title="Previous document">Histone methyltransferase simulation with multisite Zn2+ structural ions</a>
        </li>
        <li>
          <a href="umbrella_sampling.html" title="Next document">Umbrella Sampling</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.png" alt="Logo" />
    
    <h1 class="logo logo-name">OpenMM Cookbook & Tutorials</h1>
    
  </a>
</p>











<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><div class="navigation-scrollbox">
    <div class="nav-toctree">
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../cookbook.html">The OpenMM Cookbook</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../tutorials.html">The OpenMM Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#basic-tutorials">Basic Tutorials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#coarse-graining">Coarse-Graining</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../tutorials.html#advanced-tutorials">Advanced Tutorials</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="Alchemical_free_energy_calculations.html">Alchemical free energy calculations</a></li>
<li class="toctree-l3"><a class="reference internal" href="Beta_2_adrenergic_receptor_B2AR_membrane_protein_simulation_with_CHARMM.html">Beta-2-adrenergic receptor (B2AR) membrane protein simulation with CHARMM</a></li>
<li class="toctree-l3"><a class="reference internal" href="HSP90_with_ADPMg2_simulation.html">HSP90 with ADP:Mg2+ simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="Histone_methyltransferase_simulation_with_a_multisite_water_model_TIP4P-Ew.html">Histone methyltransferase simulation with a multisite water model (TIP4P-Ew)</a></li>
<li class="toctree-l3"><a class="reference internal" href="Histone_methyltransferase_simulation_with_multisite_Zn2_structural_ions.html">Histone methyltransferase simulation with multisite Zn2+ structural ions</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Run a REST simulation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#01---Construct-a-vanilla-OpenMM-system">01 - Construct a vanilla OpenMM system</a></li>
<li class="toctree-l4"><a class="reference internal" href="#02---Construct-a-REST-capable-OpenMM-system">02 - Construct a REST-capable OpenMM system</a></li>
<li class="toctree-l4"><a class="reference internal" href="#03---Run-replica-exchange">03 - Run replica exchange</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Appendix">Appendix</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="umbrella_sampling.html">Umbrella Sampling</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
    
    <ul class="extra-nav-links">
        
        <li class="toctree-l1">
            <a href="https://openmm.org">
                OpenMM.org
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://docs.openmm.org/latest/userguide/">
                User's Manual
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://docs.openmm.org/latest/developerguide/">
                Developer Guide
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://docs.openmm.org/latest/api-c++/">
                C++ API reference
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://docs.openmm.org/latest/api-python/">
                Python API reference
            </a>
        </li>
        
        <li class="toctree-l1">
            <a href="https://github.com/openmm/openmm">
                GitHub
            </a>
        </li>
        
    </ul>
    
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, The OpenMM Contributors.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../_sources/notebooks/tutorials/Running_a_REST_simulation.ipynb.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>