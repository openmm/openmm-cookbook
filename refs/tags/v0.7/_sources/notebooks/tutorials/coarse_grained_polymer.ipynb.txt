{
 "cells": [
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Implementing a Coarse-Grained Polymer Force Field\n",
    "\n",
    "This tutorial will give a basic example of creating a custom coarse-grained model in OpenMM. First it will demonstrate how to setup a molecular topology from scratch using the Python API. Next it will cover two methods for defining a custom force field: \n",
    "\n",
    "1. Using the Python API  \n",
    "2. Creating a force field XML file.  \n",
    "\n",
    "It assumes you are familiar with the concept of coarse-graining and want to learn how to implement your CG model in OpenMM."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Example System\n",
    "\n",
    "The example system in this tutorial is a Lennard-Jones bead-spring polymer model. We will demonstrate how to create a polymer melt of multiple chains. Note that we will set the bond lengths, particle mass, and Lennard-Jones interaction parameters to physical values that are typical of a residue level coarse-grained protein model (e.g. [[1]](#References))."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Creating a CG Topology\n",
    "\n",
    "To demonstrate the full flexibility of OpenMM we will use the Python API to define the topology. Note that you could create a PDB file and read that in instead.\n",
    "\n",
    "First we do the usual imports for OpenMM."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import openmm as mm\n",
    "import openmm.app as app\n",
    "import openmm.unit as unit\n",
    "import numpy as np\n",
    "from sys import stdout"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can create a new element to represent our CG bead. We set the atomic index to a large number, however the actual value is unimportant in this simulation and is just used for book-keeping purposes. We set the mass to approximate the molar mass of an amino-acid. The mass we define is important as it needs to be consistent with the chosen integration timestep."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "cgElement = app.Element(number=1000, name='CG-element', symbol='CG', mass=120)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We then create an empty `Topology` object."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Make an empty topology\n",
    "topology = app.Topology()"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we can create our simulation topology using python scripting. We will define `M = 100` polymer chains which each have `N = 10` beads. As we loop over the atoms in each chain we also record the list of bonds."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<Topology; 100 chains, 1000 residues, 1000 atoms, 900 bonds>\n"
     ]
    }
   ],
   "source": [
    "# Number of polymer chains\n",
    "M = 100\n",
    "\n",
    "# Number of atoms in each chain\n",
    "N = 10\n",
    "\n",
    "# Add each chain to the topology\n",
    "for m in range(M):\n",
    "\n",
    "    # Make the chain\n",
    "    chain = topology.addChain()\n",
    "\n",
    "    # Create the first residue in the chain\n",
    "    residue = topology.addResidue(name=\"CG-residue\", chain=chain)\n",
    "\n",
    "    # In this example each residue is one bead so we add a single atom\n",
    "    atom1 = topology.addAtom(name=\"CG-bead\", element=cgElement, residue=residue)\n",
    "\n",
    "    # Now add the rest of residues in the chain\n",
    "    for i in range(1, N):\n",
    "        residue = topology.addResidue(name=\"CG-residue\",chain=chain)\n",
    "        atom2 = topology.addAtom(name=\"CG-bead\", element=cgElement, residue=residue)\n",
    "\n",
    "        # add the bonds in as we go\n",
    "        topology.addBond(atom1, atom2)\n",
    "        atom1 = atom2\n",
    "\n",
    "# check the topology\n",
    "print(topology)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Defining Initial Positions\n",
    "\n",
    "As we have created the topology from scratch we will also need to define the initial positions from scratch. We will arrange our 100 polymer chains in a 10-by-10 grid in the *xy*-plane and each polymer will be in a linear configuration in the *z* direction. Furthermore, we set the simulation box to be cubic with length $11\\ \\mathrm{nm}$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "positions = []\n",
    "for m in range(M):\n",
    "    x0 = np.array(((m%10)*1.0, (m//10)*1.0, 0))\n",
    "    positions.append(x0)\n",
    "    for i in range(1,N):\n",
    "        xi = positions[-1] + np.array((0, 0, 0.38))\n",
    "        positions.append(xi)\n",
    "\n",
    "# Convert the list into OpenMM Quantity with units of nm\n",
    "positions = positions * unit.nanometer\n",
    "assert(len(positions) == topology.getNumAtoms())\n",
    "\n",
    "# Set the box to be a cube with length 11nm\n",
    "topology.setPeriodicBoxVectors(np.eye(3)*11.0*unit.nanometers)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can check the initial topology by saving it to a PDB file.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "# output the initial configuration\n",
    "with open('initial_config.pdb','w') as f:\n",
    "    app.PDBFile.writeFile(topology, positions, f)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The initial configuration looks like this:\n",
    "![initial configuration](initial_config.png)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Defining the Force Field\n",
    "\n",
    "We will cover two methods for defining the force field:\n",
    "\n",
    "1. Using the Python API.\n",
    "2. Creating a force field XML file.\n",
    "\n",
    "Both methods achieve the same result of defining the force field. There are pros and cons of both ways. The key points are that using the Python API is more flexible, while creating a force field XML file makes it easier to share your force field and helps reproducibility. This is demonstrated in the other OpenMM tutorials: the standard force fields such as Amber are distributed with OpenMM as XML files, while the custom forces used to do free energy calculations are defined using the Python API."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Building a System Using the Python API\n",
    "\n",
    "We can create instances of the OpenMM [Force classes](http://docs.openmm.org/latest/api-python/library.html#forces), assign parameters, and add them to the system.  First we must create a [System](http://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html#openmm.openmm.System)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# create the system and add the particles to it\n",
    "system = mm.System()\n",
    "system.setDefaultPeriodicBoxVectors(*topology.getPeriodicBoxVectors())\n",
    "for atom in topology.atoms():\n",
    "    system.addParticle(atom.element.mass)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We will then create a [HarmonicBondForce](http://docs.openmm.org/latest/api-python/generated/openmm.openmm.HarmonicBondForce.html#openmm.openmm.HarmonicBondForce) and a [CustomNonbondedForce](http://docs.openmm.org/latest/api-python/generated/openmm.openmm.CustomNonbondedForce.html#openmm.openmm.CustomNonbondedForce). \n",
    "\n",
    "For each bond that is defined in the topology we need to add it to the `HarmonicBondForce`. We set the equilibrium bond lengths and spring constants to be $0.38\\ \\mathrm{nm}$ and $1000\\ \\mathrm{kJ/mol/nm}$ respectively which are consistent with parameters used in amino-acid level CG models [[1]](#References). \n",
    "\n",
    "We define the `CustomNonbondedForce` to be a Lennard-Jones interaction. We set the value of sigma to be $0.5\\ \\mathrm{nm}$ to approximate the size of an amino acid and the value of epsilon to $1\\ \\mathrm{kJ/mol}$ to create a potential that is attractive at $300\\ \\mathrm{K}$. Please do not use these parameters for real simulations. You should consult the literature and choose an appropriate CG force field or systematically create your own parameter set! Finally, we add exclusions between atoms that are directly bonded and set a cutoff of $1.5\\ \\mathrm{nm}$.\n",
    "\n",
    "Note that because we have defined a Lennard-Jones potential we could have used the standard [NonbondedForce](http://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html), but to demonstrate the flexibility to use different user defined potentials we have used `CustomNonbondedForce`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "harmonic_bond_force = mm.HarmonicBondForce()\n",
    "\n",
    "# Add each bond to the force from the topology\n",
    "for bond in topology.bonds():\n",
    "    harmonic_bond_force.addBond(bond.atom1.index, bond.atom2.index, 0.38, 1000)\n",
    "\n",
    "# Define a Lennard-Jones potential\n",
    "expression = '4*epsilon*((sigma/r)^12-(sigma/r)^6);'\\\n",
    "            + ' sigma=0.5*(sigma1+sigma2);'\\\n",
    "            + ' epsilon=sqrt(epsilon1*epsilon2)'\n",
    "\n",
    "custom_nb_force = mm.CustomNonbondedForce(expression)\n",
    "\n",
    "custom_nb_force.addPerParticleParameter('sigma')\n",
    "custom_nb_force.addPerParticleParameter('epsilon')\n",
    "\n",
    "# Add the parameters for each particle\n",
    "for atom in topology.atoms():\n",
    "    custom_nb_force.addParticle([0.5, 1.0])\n",
    "\n",
    "# Create exclusions for directly bonded atoms\n",
    "custom_nb_force.createExclusionsFromBonds([(bond[0].index, bond[1].index) for bond in topology.bonds()], 1)\n",
    "\n",
    "# Set a cutoff of 1.5nm\n",
    "custom_nb_force.setNonbondedMethod(mm.CustomNonbondedForce.CutoffPeriodic)\n",
    "custom_nb_force.setCutoffDistance(1.5*unit.nanometers)\n",
    "\n",
    "# Add the forces to the system\n",
    "system.addForce(harmonic_bond_force)\n",
    "system.addForce(custom_nb_force)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The system is now ready to simulate. Before we run the simulation we will describe the other method of defining a force field by creating a custom force field XML file."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Creating a Force Field XML File\n",
    "\n",
    "Alternatively, we can create a custom force field XML file for our system.  This is documented in detail [in the user guide](https://docs.openmm.org/latest/userguide/application/06_creating_ffs.html).\n",
    "\n",
    "You will need to create a new file called `cg_ff.xml` using a text editor of your choice. Then paste the following lines into it:\n",
    "\n",
    "```xml\n",
    "<!-- cg_ff.xml \n",
    "Coarse-grained force field for a bead-spring polymer. -->\n",
    "<ForceField>\n",
    "\t\n",
    "    <AtomTypes>\n",
    "\t    <Type name=\"CG-bead\" class=\"CG-bead\" element=\"CG\" mass=\"120.0\"/>\n",
    "\t</AtomTypes>\n",
    "\n",
    "\t<Residues>\n",
    "        <!-- Each bead is a single residue.\n",
    "        Need a template for the different Residue types. \n",
    "        First type is the end. This only has one bond. -->\n",
    "        <Residue name=\"CG-residue-end\">\n",
    "            <Atom name=\"CG-bead\" type=\"CG-bead\"/>\n",
    "            <ExternalBond atomName=\"CG-bead\"/>\n",
    "        </Residue>\n",
    "\n",
    "        <!-- Second type is in the middle of the chain. This has two bonds. -->\n",
    "        <Residue name=\"CG-residue-middle\">\n",
    "            <Atom name=\"CG-bead\" type=\"CG-bead\"/>\n",
    "            <ExternalBond atomName=\"CG-bead\"/>\n",
    "            <ExternalBond atomName=\"CG-bead\"/>\n",
    "        </Residue>\n",
    "    </Residues>\n",
    "\n",
    "    <!-- Define a harmonic bond between the CA-beads -->\n",
    "    <HarmonicBondForce>\n",
    "        <Bond class1=\"CG-bead\" class2=\"CG-bead\" length=\"0.38\" k=\"1000.0\"/>\n",
    "    </HarmonicBondForce>\n",
    "\n",
    "    <!-- Use a custom non-bonded force for maximum flexibility.\n",
    "    The bondCutoff=1 tells it to only exclude interactions between directly bonded atoms. -->\n",
    "    <CustomNonbondedForce energy=\"4*epsilon*((sigma/r)^12-(sigma/r)^6); sigma=0.5*(sigma1+sigma2); epsilon=sqrt(epsilon1*epsilon2)\" bondCutoff=\"1\">\n",
    "        <PerParticleParameter name=\"sigma\"/>\n",
    "        <PerParticleParameter name=\"epsilon\"/>\n",
    "\t\t<Atom type=\"CG-bead\" sigma=\"0.5\" epsilon=\"1.0\"/>\n",
    "\t</CustomNonbondedForce>\n",
    "</ForceField>\n",
    "```\n",
    "\n",
    "(If you have cloned the cookbook repo then this file will already exist.)\n",
    "The comments in the above code explain what the different sections are for."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Creating the System\n",
    "\n",
    "We can now load in our previously created custom `ForceField` and use the `createSystem` method with the `topology`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "# load in the ForceField we created\n",
    "ff = app.ForceField('./cg_ff.xml')\n",
    "system2 = ff.createSystem(topology, nonbondedMethod=app.CutoffPeriodic, nonbondedCutoff=1.5*unit.nanometers)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can compare the two systems to check if they are the same. A simple way to do this is to serialize the systems as save them as XML files."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3830a3831\n",
      "> \t\t<Force forceGroup=\"0\" frequency=\"1\" name=\"CMMotionRemover\" type=\"CMMotionRemover\" version=\"1\"/>\n"
     ]
    }
   ],
   "source": [
    "with open('system1.xml', 'w') as output:\n",
    "    output.write(mm.XmlSerializer.serialize(system))\n",
    "\n",
    "with open('system2.xml', 'w') as output:\n",
    "    output.write(mm.XmlSerializer.serialize(system2))\n",
    "\n",
    "!diff system1.xml system2.xml"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We actually find they are slightly different. `system2` created by `ForceField.createSystem` has a `CMMotionRemover` that was added by default when using the `createSystem` method. If we wanted to we could add this to the first system."
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Running the Simulation\n",
    "\n",
    "We will use a `LangevinMiddleIntegrator` with a friction term of $0.01\\ \\mathrm{ps^{-1}}$ and a timestep of $0.01\\ \\mathrm{ps}$ as used in similar coarse-grained polymer models [[1]](#References). For your own models these parameters will be important and you will need to choose them carefully!  See the tutorial on [choosing simulation parameters](simulation_parameters.ipynb) for more details."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "#\"Step\",\"Potential Energy (kJ/mole)\",\"Temperature (K)\",\"Box Volume (nm^3)\",\"Speed (ns/day)\"\n",
      "10000,-2386.9404315948486,272.3156392791507,1331.0,0\n",
      "20000,-2181.3837904930115,284.380773103632,829.9882985857552,7.59e+03\n",
      "30000,-2318.7430081367493,282.7780421796789,377.31014378573184,7.55e+03\n",
      "40000,-2472.6914694309235,294.1179399674378,236.26414785705612,7.49e+03\n",
      "50000,-2849.996768951416,325.55545790607647,162.30466840921667,7.4e+03\n",
      "60000,-2936.4355487823486,300.32171489029105,155.9269807631171,7.33e+03\n",
      "70000,-3249.750735282898,324.04418408543705,152.68025370626958,7.29e+03\n",
      "80000,-3259.525100708008,305.9421179946827,150.91532595094947,7.3e+03\n",
      "90000,-3273.161273956299,289.05949299849726,148.34101529727369,7.32e+03\n",
      "100000,-3339.231357574463,297.14068336450276,150.14674964102986,7.34e+03\n",
      "110000,-3430.790554046631,295.43858680347336,153.1792452970646,7.34e+03\n"
     ]
    }
   ],
   "source": [
    "integrator = mm.LangevinMiddleIntegrator(300*unit.kelvin, 0.01/unit.picosecond, 0.010*unit.picoseconds)\n",
    "simulation = app.Simulation(topology, system, integrator)\n",
    "simulation.context.setPositions(positions)\n",
    "\n",
    "# setup simulation reporters\n",
    "# Write the trajectory to a file called 'traj.dcd'\n",
    "simulation.reporters.append(app.DCDReporter('traj.dcd', 1000, enforcePeriodicBox=False))\n",
    "\n",
    "# Report information to the screen as the simulation runs\n",
    "simulation.reporters.append(app.StateDataReporter(stdout, 10000, step=True,\n",
    "        potentialEnergy=True, temperature=True, volume=True, speed=True))\n",
    "\n",
    "\n",
    "# NVT equilibration\n",
    "simulation.step(10000)\n",
    "\n",
    "# Add a barostat\n",
    "barostatIndex=system.addForce(mm.MonteCarloBarostat(1.0*unit.bar, 300*unit.kelvin))\n",
    "simulation.context.reinitialize(preserveState=True)\n",
    "\n",
    "# Run NPT equilibration\n",
    "simulation.step(100000)\n",
    "\n",
    "\n",
    "# output the equilibrated configuration\n",
    "with open('equilibrated_config.pdb','w') as f:\n",
    "    state = simulation.context.getState(getPositions=True, enforcePeriodicBox=True)\n",
    "    topology.setPeriodicBoxVectors(state.getPeriodicBoxVectors())\n",
    "    app.PDBFile.writeFile(topology, state.getPositions(), f)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The equilibrated system will be a polymer melt that looks similar to this:\n",
    "![equilibrated polymer melt](equilibrated_config.png)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## References\n",
    "\n",
    "[1] GL Dignon, W Zheng, YC Kim, RB Best, J Mittal, PLoS computational biology 14 (1), 2018.\n",
    "https://doi.org/10.1371/journal.pcbi.1005941"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.7"
  },
  "nbsphinx": {
   "execute": "never"
  },
  "required_files": [
   "notebooks/tutorials/cg_ff.xml"
  ]
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
